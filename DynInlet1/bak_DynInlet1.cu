#include <cuda.h>
#include <iostream>
#include <ostream>
#include <fstream>
#include <sys/time.h>
#include <time.h>

using namespace std;

#define CASENAME "p_ctrl_01"

#define NUMGPU 1
#define BLOCKSIZEX 64
#define BLOCKSIZEY 1
#define BLOCKSIZEZ 1
#define BLOCKSIZELRX 64
#define BLOCKSIZELRY 1
#define BLOCKSIZELRZ 1
#define BLOCKSIZEINTERP 8
#define XDIM 64
#define YDIM 128
#define ZDIM 4
#define TMAX  500000
#define STARTF 0
#define DYNY 64
#define KP 0.01f //p-control constant

#define OBSTR1 32.f
#define OBSTX1 48.5f
#define OBSTY1 20.5f
#define OBSTZ1 32.5f

#define OBSTR2 8.f
#define OBSTX2 32.5f
#define OBSTY2 20.5f
#define OBSTZ2 32.5f

#define LRFACTOR 0.5f
#define LRLEVEL 2
#define LRX0 128.25f    //minimum x coord of LR
#define XLRDIM 128    //number of nodes in x
#define LRY0 30.25f
#define YLRDIM 80
#define LRZ0 -0.75f
#define ZLRDIM 8
#define ORDER 2 //order of accuracy of interpolation

#define RE 1080.f//2000.f//100.f;
#define UMAX 0.06f
#define SmagLES 1 //1,0
#define MODEL "MRT" //BGK,MRT,STREAM
#define REFINEMENT 0 //1,0
#define CS 0.01f
#define DPDX 0.f
#define DPDY -3.91e-7

#define VELAV 1
#define START_VELAV   100000
#define START_VELFLUC 250000

inline __device__ int ImageFcnLR(float x, float y, float z)
{
    int value = 0;
    if(abs(x-OBSTX1) < OBSTR1 && abs(y-OBSTY1) < OBSTR1)
    {
        value = 10;
    }
    return value;
}

inline __device__ int ImageFcn(int x, int y, int z, int t)
{
    int value = 0;
    if(abs(x-OBSTX2) < OBSTR2 && abs(y-OBSTY2) < OBSTR2 && t < 1000)
        value = 10;
    if(abs(x-OBSTX2-3) < OBSTR2 && abs(y-OBSTY2-3) < OBSTR2 && t < 1000 && z == 10)
        value = 10;
    if(x == 0)
        value = 1;//50;//400;
    else if(x == XDIM-1)
        value = 1;//51;//300;
    else if(y == 0)
        value = 52;//1;//22;
    else if(y == YDIM-1)
        value = 53;//1;


    return value;
}

inline __device__ float PoisProf (float x){
    float radius = (YDIM-1-1)*0.5f;
    float result = -1.5f*(((1.0f-(x-0.5f)/radius))*((1.0f-(x-0.5f)/radius))-1.0f);
    return (result);
}

inline __device__ float PoisProf3D (float x, float y){
    x = x-0.5f;
    y = y-0.5f;
    //float H = 41.f;
    return UMAX;//2.25f*16.f*UMAX*x*y*(H-x)*(H-y)/((H)*(H)*(H)*(H));
//    float radius = (YDIM-1-1)*0.5f;
//    float result = -1.0f*(((1.0f-(x-0.5f)/radius))*((1.0f-(x-0.5f)/radius))-1.0f);
//    return (result);
}

int
timeval_subtract (double *result, struct timeval *x, struct timeval *y)
{
  struct timeval result0;

  /* Perform the carry for the later subtraction by updating y. */
  if (x->tv_usec < y->tv_usec) {
    int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
    y->tv_usec -= 1000000 * nsec;
    y->tv_sec += nsec;
  }
  if (x->tv_usec - y->tv_usec > 1000000) {
    int nsec = (y->tv_usec - x->tv_usec) / 1000000;
    y->tv_usec += 1000000 * nsec;
    y->tv_sec -= nsec;
  }

  /* Compute the time remaining to wait.
     tv_usec is certainly positive. */
  result0.tv_sec = x->tv_sec - y->tv_sec;
  result0.tv_usec = x->tv_usec - y->tv_usec;
  *result = ((double)result0.tv_usec)/1e6 + (double)result0.tv_sec;

  /* Return 1 if result is negative. */
  return x->tv_sec < y->tv_sec;
}

__device__ int dmin(int a, int b)
{
    if (a<b) return a;
    else return b-1;
}
__device__ int dmax(int a)
{
    if (a>-1) return a;
    else return 0;
}
__device__ int dmax(int a,int b)
{
    if (a>b) return a;
    else return b;
}
__device__ int dmin_p(int a, int b)
{
    if (a<b) return a;
    else return 0;
}
__device__ int dmax_p(int a, int b)
{
    if (a>-1) return a;
    else return b-1;
}

inline __device__ float trilinear_interp (float v000, float v001, float v010, float v011,
                                          float v100, float v101, float v110, float v111, float x, float y, float z){
    return v000*(1.f-x)*(1.f-y)*(1.f-z)+
           v001*(    x)*(1.f-y)*(1.f-z)+
           v010*(1.f-x)*(    y)*(1.f-z)+
           v011*(    x)*(    y)*(1.f-z)+
           v100*(1.f-x)*(1.f-y)*(    z)+
           v101*(    x)*(1.f-y)*(    z)+
           v110*(1.f-x)*(    y)*(    z)+
           v111*(    x)*(    y)*(    z);
}

inline __device__ int f_mem(int f_num, int x, int y, int z, size_t pitch, int zInner)
{
    int index = (x+y*pitch+z*YDIM*pitch)+f_num*pitch*YDIM*(zInner);
    index = dmax(index);
    index = dmin(index,19*pitch*YDIM*(zInner));
    return index;
}

inline __device__ int f_memLR(int f_num, int x, int y, int z, size_t pitch, int zInner)
{
    int index = (x+y*pitch+z*YLRDIM*pitch)+f_num*pitch*YLRDIM*(zInner);
    index = dmax(index);
    index = dmin(index,19*pitch*YLRDIM*(zInner));
    return index;
}

inline __device__ int f_mem_interp(int m_num, int x, int y, int z, int pitch, int zInner)
{
    int index = (x+y*pitch+z*(YLRDIM*LRFACTOR+1)*pitch)+m_num*pitch*(YLRDIM*LRFACTOR+1)*(zInner);
    index = dmax(index);
    index = dmin(index,9*pitch*(YLRDIM*LRFACTOR+1)*(zInner));
    return index;
}

inline __device__ int buff_mem_interp(int m_num, int x, int y, int pitch, int zInner)
{
    int index = (x+y*pitch+m_num*(YLRDIM*LRFACTOR+1)*pitch);
    index = dmax(index);
    index = dmin(index,9*pitch*(YLRDIM*LRFACTOR+1));
    return index;
}

inline __device__ int buff_mem(int f_num, int x, int y, size_t pitch)
{
    int index = (x+y*pitch)+f_num*pitch*YDIM;
    index = dmax(index);
    index = dmin(index,19*pitch*YDIM);
    return index;
}

inline __device__ int buff_memLR(int f_num, int x, int y, size_t pitch)
{
    int index = (x+y*pitch)+f_num*pitch*YLRDIM;
    index = dmax(index);
    index = dmin(index,19*pitch*YLRDIM);
    return index;
}

inline __device__ void AddForce(float* f, float dpdy)
{
//    f[1] -= 0.0555555556f*3.f*DPDX;
//    f[3] += 0.0555555556f*3.f*DPDX;
//    f[5] -= 0.0277777778f*3.f*DPDX;
//    f[6] += 0.0277777778f*3.f*DPDX;
//    f[7] += 0.0277777778f*3.f*DPDX;
//    f[8] -= 0.0277777778f*3.f*DPDX;
//    f[10]-= 0.0277777778f*3.f*DPDX;
//    f[12]+= 0.0277777778f*3.f*DPDX;
//    f[15]-= 0.0277777778f*3.f*DPDX;
//    f[17]+= 0.0277777778f*3.f*DPDX;

    f[2] -= 0.0555555556f*3.f*dpdy;
    f[4] += 0.0555555556f*3.f*dpdy;
    f[5] -= 0.0277777778f*3.f*dpdy;
    f[6] -= 0.0277777778f*3.f*dpdy;
    f[7] += 0.0277777778f*3.f*dpdy;
    f[8] += 0.0277777778f*3.f*dpdy;
    f[11]-= 0.0277777778f*3.f*dpdy;
    f[13]+= 0.0277777778f*3.f*dpdy;
    f[16]-= 0.0277777778f*3.f*dpdy;
    f[18]+= 0.0277777778f*3.f*dpdy;

}

inline __device__ void Moments(float* f, float* m)
{
    m[0 ] = f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6]+f[7]+f[8]+f[9]+f[10]+f[11]+f[12]+f[13]+f[14]+f[15]+f[16]+f[17]+f[18];
	m[1 ] = -30.f*f[0]+-11.f*f[1]+-11.f*f[2]+-11.f*f[3]+-11.f*f[4]+  8.f*f[5]+  8.f*f[6]+  8.f*f[7]+  8.f*f[8]+-11.f*f[9]+  8.f*f[10]+  8.f*f[11]+  8.f*f[12]+  8.f*f[13]+-11.f*f[14]+  8.f*f[15]+  8.f*f[16]+  8.f*f[17]+  8.f*f[18];
	m[2 ] =  12.f*f[0]+ -4.f*f[1]+ -4.f*f[2]+ -4.f*f[3]+ -4.f*f[4]+    f[5]+    f[6]+    f[7]+    f[8]+ -4.f*f[9]+    f[10]+      f[11]+    f[12]+    f[13]+ -4.f*f[14]+    f[15]+    f[16]+    f[17]+    f[18];
   	m[3 ] = f[1]-f[3]+f[5]-f[6]-f[7]+f[8]+f[10]-f[12]+f[15]-f[17];
	m[4 ] =           -4.f*f[1]         +  4.f*f[3]         +    f[5]+ -  f[6]+ -  f[7]+    f[8]         +    f[10]          + -  f[12]                    +    f[15]          + -  f[17]          ;
    m[5 ] = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
	m[6 ] =                    -4.f*f[2]         +  4.f*f[4]+    f[5]+    f[6]+ -  f[7]+ -  f[8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];
    m[7 ] = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
	m[8 ] =                                                                                 + -4.f*f[9]+    f[10]+    f[11]+    f[12]+    f[13]+  4.f*f[14]+ -  f[15]+ -  f[16]+ -  f[17]+ -  f[18];
	m[9 ] =            2.f*f[1]+ -  f[2]+  2.f*f[3]+ -  f[4]+    f[5]+    f[6]+    f[7]+    f[8]+ -  f[9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+ -  f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
	m[10] =           -4.f*f[1]+  2.f*f[2]+ -4.f*f[3]+  2.f*f[4]+    f[5]+    f[6]+    f[7]+    f[8]+  2.f*f[9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+  2.f*f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
	m[11] =                       f[2]         +    f[4]+    f[5]+    f[6]+    f[7]+    f[8]+ -  f[9]+ -  f[10]          + -  f[12]          + -  f[14]+ -  f[15]          + -  f[17]          ;
	m[12] =                    -2.f*f[2]           -2.f*f[4]+    f[5]+    f[6]+    f[7]+    f[8]+  2.f*f[9]+ -  f[10]          + -  f[12]          +  2.f*f[14]+ -  f[15]          + -  f[17]          ;
	m[13] =                                                  f[5]+ -  f[6]+    f[7]+ -  f[8]                                                                                                   ;
	m[14] =                                                                                                         f[11]          + -  f[13]                    + -  f[16]          +    f[18];
	m[15] =                                                                                               f[10]          + -  f[12]                    + -  f[15]          +    f[17]          ;  
	m[16] =                                                  f[5]+ -  f[6]+ -  f[7]+    f[8]           -  f[10]          +    f[12]                    + -  f[15]          +    f[17]          ;  
	m[17] =                                               -  f[5]+ -  f[6]+    f[7]+    f[8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];  
	m[18] =                                                                                               f[10]+ -  f[11]+    f[12]+ -  f[13]          + -  f[15]+    f[16]+ -  f[17]+    f[18];
}

void Moments_host(float* f, float* m)
{
    m[0 ] = f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6]+f[7]+f[8]+f[9]+f[10]+f[11]+f[12]+f[13]+f[14]+f[15]+f[16]+f[17]+f[18];
	m[1 ] = -30.f*f[0]+-11.f*f[1]+-11.f*f[2]+-11.f*f[3]+-11.f*f[4]+  8.f*f[5]+  8.f*f[6]+  8.f*f[7]+  8.f*f[8]+-11.f*f[9]+  8.f*f[10]+  8.f*f[11]+  8.f*f[12]+  8.f*f[13]+-11.f*f[14]+  8.f*f[15]+  8.f*f[16]+  8.f*f[17]+  8.f*f[18];
	m[2 ] =  12.f*f[0]+ -4.f*f[1]+ -4.f*f[2]+ -4.f*f[3]+ -4.f*f[4]+    f[5]+    f[6]+    f[7]+    f[8]+ -4.f*f[9]+    f[10]+      f[11]+    f[12]+    f[13]+ -4.f*f[14]+    f[15]+    f[16]+    f[17]+    f[18];
   	m[3 ] = f[1]-f[3]+f[5]-f[6]-f[7]+f[8]+f[10]-f[12]+f[15]-f[17];
	m[4 ] =           -4.f*f[1]         +  4.f*f[3]         +    f[5]+ -  f[6]+ -  f[7]+    f[8]         +    f[10]          + -  f[12]                    +    f[15]          + -  f[17]          ;
    m[5 ] = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
	m[6 ] =                    -4.f*f[2]         +  4.f*f[4]+    f[5]+    f[6]+ -  f[7]+ -  f[8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];
    m[7 ] = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
	m[8 ] =                                                                                 + -4.f*f[9]+    f[10]+    f[11]+    f[12]+    f[13]+  4.f*f[14]+ -  f[15]+ -  f[16]+ -  f[17]+ -  f[18];
	m[9 ] =            2.f*f[1]+ -  f[2]+  2.f*f[3]+ -  f[4]+    f[5]+    f[6]+    f[7]+    f[8]+ -  f[9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+ -  f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
	m[10] =           -4.f*f[1]+  2.f*f[2]+ -4.f*f[3]+  2.f*f[4]+    f[5]+    f[6]+    f[7]+    f[8]+  2.f*f[9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+  2.f*f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
	m[11] =                       f[2]         +    f[4]+    f[5]+    f[6]+    f[7]+    f[8]+ -  f[9]+ -  f[10]          + -  f[12]          + -  f[14]+ -  f[15]          + -  f[17]          ;
	m[12] =                    -2.f*f[2]           -2.f*f[4]+    f[5]+    f[6]+    f[7]+    f[8]+  2.f*f[9]+ -  f[10]          + -  f[12]          +  2.f*f[14]+ -  f[15]          + -  f[17]          ;
	m[13] =                                                  f[5]+ -  f[6]+    f[7]+ -  f[8]                                                                                                   ;
	m[14] =                                                                                                         f[11]          + -  f[13]                    + -  f[16]          +    f[18];
	m[15] =                                                                                               f[10]          + -  f[12]                    + -  f[15]          +    f[17]          ;  
	m[16] =                                                  f[5]+ -  f[6]+ -  f[7]+    f[8]           -  f[10]          +    f[12]                    + -  f[15]          +    f[17]          ;  
	m[17] =                                               -  f[5]+ -  f[6]+    f[7]+    f[8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];  
	m[18] =                                                                                               f[10]+ -  f[11]+    f[12]+ -  f[13]          + -  f[15]+    f[16]+ -  f[17]+    f[18];
}

void InvertMoments_host(float* f, float* m)
{
float u = m[3];
float v = m[5];
float w = m[7];
f[0 ]=(0.052631579f*m[0]                           +- 0.012531328f*(m[1])+ 0.047619048f*(m[2]));
f[1 ]=(0.052631579f*m[0]+  0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+  -0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));
f[2 ]=(0.052631579f*m[0]         +  0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +   -0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[3 ]=(0.052631579f*m[0]+ -0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+   0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));                                                      
f[4 ]=(0.052631579f*m[0]         + -0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +    0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[5 ]=(0.052631579f*m[0]+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[6 ]=(0.052631579f*m[0]+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[7 ]=(0.052631579f*m[0]+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[8 ]=(0.052631579f*m[0]+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[9 ]=(0.052631579f*m[0]                  +  0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +   -0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*m[0]+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*m[0]         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]+m[8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*m[0]+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*m[0]         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]-m[8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*m[0]                  + -0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +    0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*m[0]+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*m[0]         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]-m[8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*m[0]+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*m[0]         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]+m[8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));


}

inline __device__ void mrt_meq(float* meq, float rho, float u, float v, float w)
{
    meq[ 0] = rho;
    meq[ 1] = -11.f*rho+19.f*(u*u+v*v+w*w);
    meq[ 2] = 7.53968254f*(u*u+v*v+w*w);;
    meq[ 3] = u;
    meq[ 4] = -0.666666667f*u;
    meq[ 5] = v;
    meq[ 6] = -0.666666667f*v;
    meq[ 7] = w;
    meq[ 8] = -0.666666667f*w;
    meq[ 9] = 2.f*u*u-(v*v+w*w);
    meq[11] = v*v-w*w;
    meq[13] = u*v;
    meq[14] = v*w;
    meq[15] = u*w;
}

//outputs strain rate tensor (Sxx,Syy,Szz,Sxy,Syz,Sxz) from inputs (m0,m3,m5,m7,m9,m11,m13,m14,m15)
inline __device__ void StrainRate(float* S, float* m_strain, float dx)
{
    float omega = 1.f;
    float m1 = 0.f;//(-11.f*m_strain[0]+19.f*(m_strain[1]*m_strain[1]+m_strain[2]*m_strain[2]+m_strain[3]*m_strain[3]));
    float u = m_strain[1];
    float v = m_strain[2];
    float w = m_strain[3];
    float m9 = m_strain[4]-(2.f*u*u-(v*v+w*w));
    float m11= m_strain[5]-(v*v-w*w);
    float m13= m_strain[6]-(u*v);
    float m14= m_strain[7]-(v*w);
    float m15= m_strain[8]-(u*w);
    S[0] = -0.026315789f*(    m1+19.f*omega* m9);
    S[1] = -0.013157895f*(2.f*m1-19.f*omega*(m9-3.f*m11));
    S[2] = -0.013157895f*(2.f*m1-19.f*omega*(m9+3.f*m11));
    S[3] = -1.5f*omega*m13;
    S[4] = -1.5f*omega*m14;
    S[5] = -1.5f*omega*m15;
    S[0] /= dx;
    S[1] /= dx;
    S[2] /= dx;
    S[3] /= dx;
    S[4] /= dx;
    S[5] /= dx;


}

//outputs physical moments (rho,u,v,w,Pxx,Pww,Pxy,Pyz,Pxz) from f
inline __device__ void PhysicalMoments(float* mom, float* f)
{
    mom[0] = f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6]+f[7]+f[8]+f[9]+f[10]+f[11]+f[12]+f[13]+f[14]+f[15]+f[16]+f[17]+f[18];
   	mom[1] = f[1]-f[3]+f[5]-f[6]-f[7]+f[8]+f[10]-f[12]+f[15]-f[17];
    mom[2] = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
    mom[3] = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
	mom[4] = 2.f*f[1]+-f[2]+2.f*f[3]+-f[4]+f[5]+f[6]+f[7]+f[8]+-f[9]+f[10]+-2.f*f[11]+f[12]+-2.f*f[13]+-f[14]+f[15]+-2.f*f[16]+f[17]+-2.f*f[18];
	mom[5] = f[2]+f[4]+f[5]+f[6]+f[7]+f[8]+-f[9]+-f[10]+-f[12]+-f[14]+-f[15]+-f[17];
	mom[6] = f[5]+-f[6]+f[7]+-f[8];
	mom[7] = f[11]+-f[13]+-f[16]+f[18];
	mom[8] = f[10]+-f[12]+-f[15]+f[17];
}

inline __device__ void InvertMoments(float* f, float* m)
{
float u = m[3];
float v = m[5];
float w = m[7];
f[0 ]=(0.052631579f*m[0]                           +- 0.012531328f*(m[1])+ 0.047619048f*(m[2]));
f[1 ]=(0.052631579f*m[0]+  0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+  -0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));
f[2 ]=(0.052631579f*m[0]         +  0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +   -0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[3 ]=(0.052631579f*m[0]+ -0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+   0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));                                                      
f[4 ]=(0.052631579f*m[0]         + -0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +    0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[5 ]=(0.052631579f*m[0]+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[6 ]=(0.052631579f*m[0]+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[7 ]=(0.052631579f*m[0]+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[8 ]=(0.052631579f*m[0]+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[9 ]=(0.052631579f*m[0]                  +  0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +   -0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*m[0]+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*m[0]         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]+m[8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*m[0]+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*m[0]         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]-m[8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*m[0]                  + -0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +    0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*m[0]+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*m[0]         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]-m[8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*m[0]+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*m[0]         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]+m[8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));


}

inline __device__ void InvertPhysicalMoments(float* f, float* mom, float SF)
{
    float m[19]={0};
    m[ 0] = mom[0];
    m[ 1] = (-11.f*mom[0]+19.f*(mom[1]*mom[1]+mom[2]*mom[2]+mom[3]*mom[3]));
    m[ 2] = 7.53968254f*(mom[1]*mom[1]+mom[2]*mom[2]+mom[3]*mom[3]);
    m[ 3] = mom[1];
    m[ 4] = -0.666666667f*mom[1];
    m[ 5] = mom[2];
    m[ 6] = -0.666666667f*mom[2];
    m[ 7] = mom[3];
    m[ 8] = -0.666666667f*mom[3];
    m[ 9] = mom[4]*SF+(1.f-SF)*(2.f*mom[1]*mom[1]-(mom[2]*mom[2]+mom[3]*mom[3]));
    m[11] = mom[5]*SF+(1.f-SF)*(mom[2]*mom[2]-mom[3]*mom[3]);
    m[13] = mom[6]*SF+(1.f-SF)*mom[1]*mom[2];
    m[14] = mom[7]*SF+(1.f-SF)*mom[2]*mom[3];
    m[15] = mom[8]*SF+(1.f-SF)*mom[1]*mom[3];

//    InvertMoments(f,m);
float u = m[3];
float v = m[5];
float w = m[7];
f[0 ]=(0.052631579f*m[0]                           +- 0.012531328f*(m[1])+ 0.047619048f*(m[2]));
f[1 ]=(0.052631579f*m[0]+  0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+  -0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));
f[2 ]=(0.052631579f*m[0]         +  0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +   -0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[3 ]=(0.052631579f*m[0]+ -0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+   0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));                                                      
f[4 ]=(0.052631579f*m[0]         + -0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +    0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[5 ]=(0.052631579f*m[0]+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[6 ]=(0.052631579f*m[0]+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[7 ]=(0.052631579f*m[0]+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[8 ]=(0.052631579f*m[0]+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[9 ]=(0.052631579f*m[0]                  +  0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +   -0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*m[0]+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*m[0]         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]+m[8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*m[0]+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*m[0]         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]-m[8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*m[0]                  + -0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +    0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*m[0]+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*m[0]         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]-m[8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*m[0]+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*m[0]         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]+m[8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));



}

inline __device__ void InvertPhysicalMoments_LES_fc(float* f, float* mom, float SF, float omega_f)
{
    float tau_f = 1.f/omega_f;
    float S[6]={0};
    StrainRate(S,mom,1.f);
    float Smag_f = sqrt(2.f*(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]+2.f*S[3]*S[3]+2.f*S[4]*S[4]+2.f*S[5]*S[5]));
    float tau_c = tau_f+0.5f+12.f*Smag_f*CS;
    tau_c *= 0.5f;
    float omega_c = 1.f/tau_c;
    tau_f = tau_f+Smag_f*CS;
    omega_f = 1.f/tau_f;
    SF = (1.f-omega_c)*omega_f/(LRFACTOR*omega_c*(1.f-omega_f));

    float m[19]={0};
    m[ 0] = mom[0];
    m[ 1] = (-11.f*mom[0]+19.f*(mom[1]*mom[1]+mom[2]*mom[2]+mom[3]*mom[3]));
    m[ 2] = 7.53968254f*(mom[1]*mom[1]+mom[2]*mom[2]+mom[3]*mom[3]);
    m[ 3] = mom[1];
    m[ 4] = -0.666666667f*mom[1];
    m[ 5] = mom[2];
    m[ 6] = -0.666666667f*mom[2];
    m[ 7] = mom[3];
    m[ 8] = -0.666666667f*mom[3];
    m[ 9] = mom[4]*SF+(1.f-SF)*(2.f*mom[1]*mom[1]-(mom[2]*mom[2]+mom[3]*mom[3]));
    m[11] = mom[5]*SF+(1.f-SF)*(mom[2]*mom[2]-mom[3]*mom[3]);
    m[13] = mom[6]*SF+(1.f-SF)*mom[1]*mom[2];
    m[14] = mom[7]*SF+(1.f-SF)*mom[2]*mom[3];
    m[15] = mom[8]*SF+(1.f-SF)*mom[1]*mom[3];

//    InvertMoments(f,m);
float u = m[3];
float v = m[5];
float w = m[7];
f[0 ]=(0.052631579f*m[0]                           +- 0.012531328f*(m[1])+ 0.047619048f*(m[2]));
f[1 ]=(0.052631579f*m[0]+  0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+  -0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));
f[2 ]=(0.052631579f*m[0]         +  0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +   -0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[3 ]=(0.052631579f*m[0]+ -0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+   0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));                                                      
f[4 ]=(0.052631579f*m[0]         + -0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +    0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[5 ]=(0.052631579f*m[0]+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[6 ]=(0.052631579f*m[0]+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[7 ]=(0.052631579f*m[0]+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[8 ]=(0.052631579f*m[0]+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[9 ]=(0.052631579f*m[0]                  +  0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +   -0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*m[0]+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*m[0]         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]+m[8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*m[0]+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*m[0]         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]-m[8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*m[0]                  + -0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +    0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*m[0]+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*m[0]         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]-m[8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*m[0]+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*m[0]         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]+m[8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));



}

inline __device__ void InvertPhysicalMoments_LES_cf(float* f, float* mom, float SF, float omega_c)
{
    float tau_c = 1.f/omega_c;
    float S[6]={0};
    StrainRate(S,mom,1.f);
    float Smag_c = sqrt(2.f*(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]+2.f*S[3]*S[3]+2.f*S[4]*S[4]+2.f*S[5]*S[5]));
    float tau_f = 2.f*tau_c-0.5f+1.5f*Smag_c*CS;
    float omega_f = 1.f/tau_f;
    omega_f = 1.f/tau_f;
    tau_c = tau_c+Smag_c*CS;
    omega_c = 1.f/tau_c;
    SF = (LRFACTOR*omega_c*(1.f-omega_f))/((1.f-omega_c)*omega_f);

    float m[19]={0};
    m[ 0] = mom[0];
    m[ 1] = (-11.f*mom[0]+19.f*(mom[1]*mom[1]+mom[2]*mom[2]+mom[3]*mom[3]));
    m[ 2] = 7.53968254f*(mom[1]*mom[1]+mom[2]*mom[2]+mom[3]*mom[3]);
    m[ 3] = mom[1];
    m[ 4] = -0.666666667f*mom[1];
    m[ 5] = mom[2];
    m[ 6] = -0.666666667f*mom[2];
    m[ 7] = mom[3];
    m[ 8] = -0.666666667f*mom[3];
    m[ 9] = mom[4]*SF+(1.f-SF)*(2.f*mom[1]*mom[1]-(mom[2]*mom[2]+mom[3]*mom[3]));
    m[11] = mom[5]*SF+(1.f-SF)*(mom[2]*mom[2]-mom[3]*mom[3]);
    m[13] = mom[6]*SF+(1.f-SF)*mom[1]*mom[2];
    m[14] = mom[7]*SF+(1.f-SF)*mom[2]*mom[3];
    m[15] = mom[8]*SF+(1.f-SF)*mom[1]*mom[3];

//    InvertMoments(f,m);
float u = m[3];
float v = m[5];
float w = m[7];
f[0 ]=(0.052631579f*m[0]                           +- 0.012531328f*(m[1])+ 0.047619048f*(m[2]));
f[1 ]=(0.052631579f*m[0]+  0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+  -0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));
f[2 ]=(0.052631579f*m[0]         +  0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +   -0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[3 ]=(0.052631579f*m[0]+ -0.1f*u                  +-0.0045948204f*(m[1])+-0.015873016f*(m[2])+   0.1f*(m[4])                 + 0.055555556f*((m[9])-m[10]));                                                      
f[4 ]=(0.052631579f*m[0]         + -0.1f*v         +-0.0045948204f*(m[1])+-0.015873016f*(m[2])             +    0.1f*(m[6])   +-0.027777778f*((m[9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[5 ]=(0.052631579f*m[0]+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[6 ]=(0.052631579f*m[0]+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[7 ]=(0.052631579f*m[0]+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[8 ]=(0.052631579f*m[0]+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[9 ]=(0.052631579f*m[0]                  +  0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +   -0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*m[0]+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*m[0]         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]+m[8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*m[0]+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*m[0]         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]-m[8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*m[0]                  + -0.1f*w+-0.0045948204f*(m[1])+-0.015873016f*(m[2])                +    0.1f*(m[8])+-0.027777778f*((m[9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*m[0]+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+ 0.025f*(m[4]-m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*m[0]         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             +  0.025f*(m[6]-m[8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*m[0]+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])+-0.025f*(m[4]+m[8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*m[0]         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[1])+ 0.003968254f*(m[2])             + -0.025f*(m[6]+m[8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[9]) +( 0.25f*(m[14]))));



}



inline __device__ void mrt_collide(float* f, float omega, float dpdy)
{
    float m[19];
    //float u,v,w;    
    m[3] = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    m[5] = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    m[7] = f[ 9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
    m[0] = f[ 0]+f[ 1]+f[ 2]+f[ 3]+f[ 4]+f[ 5]+f[ 6]+f[ 7]+f[ 8]+f[ 9]+
          f[10]+f[11]+f[12]+f[13]+f[14]+f[15]+f[16]+f[17]+f[18];

    m[ 1]  = 19.f*(-f[ 0]+ f[ 5]+f[ 6]+f[ 7]+f[ 8]+f[10]+f[11]+f[12]+f[13]+f[15]+f[16]+f[17]+f[18]   -(m[3]*m[3]+m[5]*m[5]+m[7]*m[7]));//+8.f*(f[ 5]+f[ 6]+f[ 7]+f[ 8]+f[10]+f[11]+f[12]+f[13]+f[15]+f[16]+f[17]+f[18]);
    m[ 2]  =  12.f*f[ 0]+ -4.f*f[ 1]+ -4.f*f[ 2]+ -4.f*f[ 3]+ -4.f*f[ 4]+      f[ 5]+      f[ 6]+      f[ 7]+      f[ 8]+ -4.f*f[ 9]+    f[10]+        f[11]+      f[12]+      f[13]+ -4.f*f[14]+      f[15]+      f[16]+      f[17]+      f[18] -7.53968254f*(m[3]*m[3]+m[5]*m[5]+m[7]*m[7]);
    m[ 4]  = 1.666666667f*(-3.f*f[1]+3.f*f[ 3]+m[3]);
    m[ 6]  = 1.666666667f*(-3.f*f[2]+3.f*f[ 4]+m[5]);
    m[ 8]  = 1.666666667f*(-3.f*f[9]+3.f*f[14]+m[7]);
    m[ 9]  = 2.f*f[ 1]+  -  f[ 2]+  2.f*f[ 3]+  -  f[ 4]+ f[ 5]+ f[ 6]+ f[ 7]+ f[ 8]+-    f[ 9]+ f[10]+ -2.f*f[11]+ f[12]+-2.f*f[13]+-    f[14]+ f[15]+ -2.f*f[16]+ f[17]+-2.f*f[18]  -(2.f*m[3]*m[3]-(m[5]*m[5]+m[7]*m[7]));
    m[10] =-4.f*f[ 1]+ 2.f*f[ 2]+ -4.f*f[ 3]+ 2.f*f[ 4]+ f[ 5]+ f[ 6]+ f[ 7]+ f[ 8]+ 2.f*f[ 9]+ f[10]+ -2.f*f[11]+ f[12]+-2.f*f[13]+ 2.f*f[14]+ f[15]+ -2.f*f[16]+ f[17]+-2.f*f[18];
    m[11] =             f[ 2]         +     f[ 4]+ f[ 5]+ f[ 6]+ f[ 7]+ f[ 8]+-    f[ 9]+-f[10]          +-f[12]         +-    f[14]+-f[15]          +-f[17]         -(m[5]*m[5]-m[7]*m[7]);
    m[12] =        -2.f*f[ 2]          -2.f*f[ 4]+ f[ 5]+ f[ 6]+ f[ 7]+ f[ 8]+ 2.f*f[ 9]+-f[10]          +-f[12]         + 2.f*f[14]+-f[15]          +-f[17]         ;
    m[13] =                                  f[ 5]+-f[ 6]+ f[ 7]+-f[ 8]                                                                             -m[3]*m[5];
    m[14] =                                                                    f[11]     +-    f[13]              + -    f[16]     +     f[18]  -m[5]*m[7];
    m[15] =                                                          f[10]        + - f[12]                  +-f[15]          + f[17]           -m[3]*m[7];  
    m[16] =                                  f[ 5]+-f[ 6]+-f[ 7]+ f[ 8]         -f[10]        +   f[12]                  +-f[15]          + f[17]         ;  
    m[17] =                                 -f[ 5]+-f[ 6]+ f[ 7]+ f[ 8]              +     f[11]     +-    f[13]              +      f[16]     +-    f[18];  
    m[18] =                                                          f[10]+-     f[11]+ f[12]+-    f[13]         +-f[15]+      f[16]+-f[17]+     f[18];


if(SmagLES == 1)
{
//    float Pxx = 0.33333333f*(m[1]+2.f*m[0]+m[9]);
//    float Pyy = Pxx+0.5f*(m[11]-m[9]);//0.3333333f*(m[1]+2.f*m[0]+0.5f*(3.f*m[11]-m[9]));
//    float Pzz = Pyy-m[11];
//    float Q11 = 0.33333333f*(m[0])+m[3]*m[3]-Pxx;
//    float Q22 = 0.33333333f*(m[0])+m[5]*m[5]-Pyy;
//    float Q33 = 0.33333333f*(m[0])+m[7]*m[7]-Pzz;
//    float Q12 = m[3]*m[5]-m[13];
//    float Q23 = m[5]*m[7]-m[14];
//    float Q13 = m[3]*m[7]-m[15];
////    float Q11 = 0.33333333f*m[0]+m[3]*m[3]-Pxx;
////    float Q22 = 0.33333333f*m[0]+m[5]*m[5]-Pyy;
////    float Q33 = 0.33333333f*m[0]+m[7]*m[7]-Pzz;
////    float Q12 = 0.33333333f*m[0]+m[3]*m[5]-m[13];
////    float Q23 = 0.33333333f*m[0]+m[5]*m[7]-m[14];
////    float Q13 = 0.33333333f*m[0]+m[3]*m[7]-m[15];

float usqr = m[3]*m[3]+m[5]*m[5]+m[7]*m[7];
float u = m[3];
float v = m[5];
float w = m[7];
float rho = m[0];

float feq1 = 0.1031746045f*rho+ 0.032375918f*usqr+  0.1666666667f*u                                                   ;
float feq2 = 0.1031746045f*rho+ 0.032375918f*usqr+  0.1666666667f*v                       ;
float feq3 = 0.1031746045f*rho+ 0.032375918f*usqr+ -0.1666666667f*u                                                   ;
float feq4 = 0.1031746045f*rho+ 0.032375918f*usqr+ -0.1666666667f*v                       ;
float feq5 = 0.0158730149f*rho+ 0.033572690f*usqr+  0.083333333f*( u+v)                            ;
float feq6 = 0.0158730149f*rho+ 0.033572690f*usqr+ -0.083333333f*( u-v)                            ;
float feq7 = 0.0158730149f*rho+ 0.033572690f*usqr+ -0.083333333f*( u+v)                            ;
float feq8 = 0.0158730149f*rho+ 0.033572690f*usqr+  0.083333333f*( u-v)                            ;
float feq9 = 0.1031746045f*rho+ 0.032375918f*usqr+  0.1666666667f*w;
float feq10= 0.0158730149f*rho+ 0.033572690f*usqr+  0.083333333f*( u+w)                                 ;
float feq11= 0.0158730149f*rho+ 0.033572690f*usqr+  0.083333333f*( v+w);
float feq12= 0.0158730149f*rho+ 0.033572690f*usqr+ -0.083333333f*( u-w)                            ;
float feq13= 0.0158730149f*rho+ 0.033572690f*usqr+ -0.083333333f*( v-w);
float feq14= 0.1031746045f*rho+ 0.032375918f*usqr+ -0.1666666667f*w;
float feq15= 0.0158730149f*rho+ 0.033572690f*usqr+  0.083333333f*(u-w)                            ;
float feq16= 0.0158730149f*rho+ 0.033572690f*usqr+  0.083333333f*(v-w);
float feq17= 0.0158730149f*rho+ 0.033572690f*usqr+ -0.083333333f*(u+w)                            ;
float feq18= 0.0158730149f*rho+ 0.033572690f*usqr+ -0.083333333f*(v+w);

feq1 +=  0.055555556f*(2.f*u*u-(v*v+w*w));
feq2 += -0.027777778f*(2.f*u*u-(v*v+w*w))+  0.083333333f*(v*v-w*w);
feq3 +=  0.055555556f*(2.f*u*u-(v*v+w*w));
feq4 += -0.027777778f*(2.f*u*u-(v*v+w*w))+  0.083333333f*(v*v-w*w);
feq5 +=  0.027777778f*(2.f*u*u-(v*v+w*w))+  0.083333333f*(v*v-w*w)+  0.25f*u*v                              ;
feq6 +=  0.027777778f*(2.f*u*u-(v*v+w*w))+  0.083333333f*(v*v-w*w)+ -0.25f*u*v                              ;
feq7 +=  0.027777778f*(2.f*u*u-(v*v+w*w))+  0.083333333f*(v*v-w*w)+  0.25f*u*v                              ;
feq8 +=  0.027777778f*(2.f*u*u-(v*v+w*w))+  0.083333333f*(v*v-w*w)+ -0.25f*u*v                              ;
feq9 += -0.027777778f*(2.f*u*u-(v*v+w*w))+ -0.083333333f*(v*v-w*w)                                            ;
feq10+=  0.027777778f*(2.f*u*u-(v*v+w*w))+ -0.083333333f*(v*v-w*w)                              +  0.25f*u*w;
feq11+= -0.055555556f*(2.f*u*u-(v*v+w*w))                                      +  0.25f*v*w             ;
feq12+=  0.027777778f*(2.f*u*u-(v*v+w*w))+ -0.083333333f*(v*v-w*w)                              + -0.25f*u*w;
feq13+= -0.055555556f*(2.f*u*u-(v*v+w*w))                                        -0.25f*v*w             ;
feq14+= -0.027777778f*(2.f*u*u-(v*v+w*w))+ -0.083333333f*(v*v-w*w)                                            ;
feq15+=  0.027777778f*(2.f*u*u-(v*v+w*w))+ -0.083333333f*(v*v-w*w)                              + -0.25f*u*w;
feq16+= -0.055555556f*(2.f*u*u-(v*v+w*w))                                      + -0.25f*v*w             ;
feq17+=  0.027777778f*(2.f*u*u-(v*v+w*w))+ -0.083333333f*(v*v-w*w)                              +  0.25f*u*w;
feq18+= -0.055555556f*(2.f*u*u-(v*v+w*w))                                      +  0.25f*v*w                 ;

float PI11 = (f[1 ]-feq1 )+(f[3 ]-feq3 )+(f[5 ]-feq5 )+(f[6 ]-feq6 )+(f[7 ]-feq7 )+(f[8 ]-feq8 )+(f[10]-feq10)+(f[12]-feq12)+(f[15]-feq15)+(f[17]-feq17);
float PI22 = (f[2 ]-feq2 )+(f[4 ]-feq4 )+(f[5 ]-feq5 )+(f[6 ]-feq6 )+(f[7 ]-feq7 )+(f[8 ]-feq8 )+(f[11]-feq11)+(f[13]-feq13)+(f[16]-feq16)+(f[18]-feq18);
float PI33 = (f[9 ]-feq9 )+(f[14]-feq14)+(f[10]-feq10)+(f[12]-feq12)+(f[15]-feq15)+(f[17]-feq17)+(f[11]-feq11)+(f[13]-feq13)+(f[16]-feq16)+(f[18]-feq18);
float PI12 = (f[5 ]-feq5 )+(f[7 ]-feq7 )-(f[6 ]-feq6 )-(f[8 ]-feq8 );
float PI13 = (f[10]-feq10)+(f[17]-feq17)-(f[12]-feq12)-(f[15]-feq15);
float PI23 = (f[11]-feq11)+(f[18]-feq18)-(f[13]-feq13)-(f[16]-feq16);

float Q = sqrt(PI11*PI11+PI22*PI22+PI33*PI33+2.f*PI12*PI12+2.f*PI23*PI23+2.f*PI13*PI13);


    //float Q = sqrt(Q11*Q11+Q22*Q22+Q33*Q33+2.f*Q12*Q12+2.f*Q23*Q23+2.f*Q13*Q13);
    float tau0 = 1.f/omega;
    float tau = 0.5f*tau0+0.5f*sqrt(tau0*tau0+18.f*CS*sqrt(2.f)*Q);
    omega = 1.f/tau;
}




f[ 0] -=- 0.012531328f*(m[ 1])+ 0.047619048f*(m[ 2]);
f[ 1] -=-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+  -0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])*omega-m[10]);
f[ 2] -=-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +   -0.1f*(m[ 6])   +-0.027777778f*((m[ 9])*omega-m[10])+ 0.083333333f*((m[11])*omega-m[12]);
f[ 3] -=-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+   0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])*omega-m[10]);                                                                                         
f[ 4] -=-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +    0.1f*(m[ 6])   +-0.027777778f*((m[ 9])*omega-m[10])+ 0.083333333f*((m[11])*omega-m[12]);
f[ 5] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ omega*(0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13])));
f[ 6] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ omega*(0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13])));
f[ 7] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ omega*(0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13])));
f[ 8] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ omega*(0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13])));
f[ 9] -=-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +   -0.1f*(m[ 8])+-0.027777778f*((m[ 9])*omega-m[10])+-0.083333333f*((m[11])*omega-m[12]);                                       
f[10] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ omega*(0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15])));
f[11] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]+m[ 8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+omega*(-0.055555556f*(m[ 9]) +( 0.25f*(m[14])));
f[12] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ omega*(0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15])));
f[13] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]-m[ 8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+omega*(-0.055555556f*(m[ 9]) +(-0.25f*(m[14])));
f[14] -=-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +    0.1f*(m[ 8])+-0.027777778f*((m[ 9])*omega-m[10])+-0.083333333f*((m[11])*omega-m[12]);                                      
f[15] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ omega*(0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15])));
f[16] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]-m[ 8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+omega*(-0.055555556f*(m[ 9]) +(-0.25f*(m[14])));
f[17] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ omega*(0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15])));
f[18] -= 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]+m[ 8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+omega*(-0.055555556f*(m[ 9]) +( 0.25f*(m[14])));

AddForce(f,dpdy);

}

inline __device__ void North_Extrap(float* f, float rho)
{
    float m[19];
    //rho = 1.0f;
    float u = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    float v = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    float w = f[ 9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];


    m[ 1]  = -30.f*f[ 0]+-11.f*f[ 1]+-11.f*f[ 2]+-11.f*f[ 3]+-11.f*f[ 4]+  8.f*f[ 5]+  8.f*f[ 6]+  8.f*f[ 7]+  8.f*f[ 8]+-11.f*f[ 9]+  8.f*f[10]+  8.f*f[11]+  8.f*f[12]+  8.f*f[13]+-11.f*f[14]+  8.f*f[15]+  8.f*f[16]+  8.f*f[17]+  8.f*f[18];
    m[ 2]  =  12.f*f[ 0]+ -4.f*f[ 1]+ -4.f*f[ 2]+ -4.f*f[ 3]+ -4.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -4.f*f[ 9]+    f[10]+      f[11]+    f[12]+    f[13]+ -4.f*f[14]+    f[15]+    f[16]+    f[17]+    f[18];
    m[ 4]  =           -4.f*f[ 1]         +  4.f*f[ 3]         +    f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]         +    f[10]          + -  f[12]                    +    f[15]          + -  f[17]          ;
    m[ 6]  =                    -4.f*f[ 2]         +  4.f*f[ 4]+    f[ 5]+    f[ 6]+ -  f[ 7]+ -  f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];
    m[ 8]  =                                                                                 + -4.f*f[ 9]+    f[10]+    f[11]+    f[12]+    f[13]+  4.f*f[14]+ -  f[15]+ -  f[16]+ -  f[17]+ -  f[18];
    m[ 9]  =            2.f*f[ 1]+ -  f[ 2]+  2.f*f[ 3]+ -  f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+ -  f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[10] =           -4.f*f[ 1]+  2.f*f[ 2]+ -4.f*f[ 3]+  2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+  2.f*f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[11] =                       f[ 2]         +    f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+ -  f[10]          + -  f[12]          + -  f[14]+ -  f[15]          + -  f[17]          ;
    m[12] =                    -2.f*f[ 2]           -2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+ -  f[10]          + -  f[12]          +  2.f*f[14]+ -  f[15]          + -  f[17]          ;
    m[13] =                                                  f[ 5]+ -  f[ 6]+    f[ 7]+ -  f[ 8]                                                                                                   ;
    m[14] =                                                                                                         f[11]          + -  f[13]                    + -  f[16]          +    f[18];
    m[15] =                                                                                               f[10]          + -  f[12]                    + -  f[15]          +    f[17]          ;  
    m[16] =                                                  f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]           -  f[10]          +    f[12]                    + -  f[15]          +    f[17]          ;  
    m[17] =                                               -  f[ 5]+ -  f[ 6]+    f[ 7]+    f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];  
    m[18] =                                                                                               f[10]+ -  f[11]+    f[12]+ -  f[13]          + -  f[15]+    f[16]+ -  f[17]+    f[18];

f[ 0] =(0.052631579f*rho                           +- 0.012531328f*(m[ 1])+ 0.047619048f*(m[ 2]));
f[ 1] =(0.052631579f*rho+  0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+  -0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));
f[ 2] =(0.052631579f*rho         +  0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +   -0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 3] =(0.052631579f*rho+ -0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+   0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));        
f[ 4] =(0.052631579f*rho         + -0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +    0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 5] =(0.052631579f*rho+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 6] =(0.052631579f*rho+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 7] =(0.052631579f*rho+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 8] =(0.052631579f*rho+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 9] =(0.052631579f*rho                  +  0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +   -0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*rho+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*rho         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]+m[ 8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*rho+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*rho         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]-m[ 8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*rho                  + -0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +    0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*rho+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*rho         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]-m[ 8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*rho+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*rho         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]+m[ 8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));

}

inline __device__ void South_Extrap(float* f, float v)
{
    float m[19];
    float u = 0.f;//f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    float w = 0.f;//f[ 9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
    float rho = f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6]+f[7]+f[8]+f[9]+f[10]+f[11]+f[12]+f[13]+f[14]+f[15]+f[16]+f[17]+f[18];

    m[ 1]  = -30.f*f[ 0]+-11.f*f[ 1]+-11.f*f[ 2]+-11.f*f[ 3]+-11.f*f[ 4]+  8.f*f[ 5]+  8.f*f[ 6]+  8.f*f[ 7]+  8.f*f[ 8]+-11.f*f[ 9]+  8.f*f[10]+  8.f*f[11]+  8.f*f[12]+  8.f*f[13]+-11.f*f[14]+  8.f*f[15]+  8.f*f[16]+  8.f*f[17]+  8.f*f[18];
    m[ 2]  =  12.f*f[ 0]+ -4.f*f[ 1]+ -4.f*f[ 2]+ -4.f*f[ 3]+ -4.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -4.f*f[ 9]+    f[10]+      f[11]+    f[12]+    f[13]+ -4.f*f[14]+    f[15]+    f[16]+    f[17]+    f[18];
    m[ 4]  =           -4.f*f[ 1]         +  4.f*f[ 3]         +    f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]         +    f[10]          + -  f[12]                    +    f[15]          + -  f[17]          ;
    m[ 6]  =                    -4.f*f[ 2]         +  4.f*f[ 4]+    f[ 5]+    f[ 6]+ -  f[ 7]+ -  f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];
    m[ 8]  =                                                                                 + -4.f*f[ 9]+    f[10]+    f[11]+    f[12]+    f[13]+  4.f*f[14]+ -  f[15]+ -  f[16]+ -  f[17]+ -  f[18];
    m[ 9]  =            2.f*f[ 1]+ -  f[ 2]+  2.f*f[ 3]+ -  f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+ -  f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[10] =           -4.f*f[ 1]+  2.f*f[ 2]+ -4.f*f[ 3]+  2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+  2.f*f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[11] =                       f[ 2]         +    f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+ -  f[10]          + -  f[12]          + -  f[14]+ -  f[15]          + -  f[17]          ;
    m[12] =                    -2.f*f[ 2]           -2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+ -  f[10]          + -  f[12]          +  2.f*f[14]+ -  f[15]          + -  f[17]          ;
    m[13] =                                                  f[ 5]+ -  f[ 6]+    f[ 7]+ -  f[ 8]                                                                                                   ;
    m[14] =                                                                                                         f[11]          + -  f[13]                    + -  f[16]          +    f[18];
    m[15] =                                                                                               f[10]          + -  f[12]                    + -  f[15]          +    f[17]          ;  
    m[16] =                                                  f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]           -  f[10]          +    f[12]                    + -  f[15]          +    f[17]          ;  
    m[17] =                                               -  f[ 5]+ -  f[ 6]+    f[ 7]+    f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];  
    m[18] =                                                                                               f[10]+ -  f[11]+    f[12]+ -  f[13]          + -  f[15]+    f[16]+ -  f[17]+    f[18];

f[ 0] =(0.052631579f*rho                           +- 0.012531328f*(m[ 1])+ 0.047619048f*(m[ 2]));
f[ 1] =(0.052631579f*rho+  0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+  -0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));
f[ 2] =(0.052631579f*rho         +  0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +   -0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 3] =(0.052631579f*rho+ -0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+   0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));        
f[ 4] =(0.052631579f*rho         + -0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +    0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 5] =(0.052631579f*rho+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 6] =(0.052631579f*rho+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 7] =(0.052631579f*rho+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 8] =(0.052631579f*rho+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 9] =(0.052631579f*rho                  +  0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +   -0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*rho+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*rho         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]+m[ 8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*rho+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*rho         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]-m[ 8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*rho                  + -0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +    0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*rho+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*rho         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]-m[ 8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*rho+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*rho         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]+m[ 8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));

}

inline __device__ void East_Extrap(float* f, float rho)
{
    float m[19];
    //rho = 0.0f;
    float u = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    float v = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    float w = f[ 9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];


    m[ 1]  = -30.f*f[ 0]+-11.f*f[ 1]+-11.f*f[ 2]+-11.f*f[ 3]+-11.f*f[ 4]+  8.f*f[ 5]+  8.f*f[ 6]+  8.f*f[ 7]+  8.f*f[ 8]+-11.f*f[ 9]+  8.f*f[10]+  8.f*f[11]+  8.f*f[12]+  8.f*f[13]+-11.f*f[14]+  8.f*f[15]+  8.f*f[16]+  8.f*f[17]+  8.f*f[18];
    m[ 2]  =  12.f*f[ 0]+ -4.f*f[ 1]+ -4.f*f[ 2]+ -4.f*f[ 3]+ -4.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -4.f*f[ 9]+    f[10]+      f[11]+    f[12]+    f[13]+ -4.f*f[14]+    f[15]+    f[16]+    f[17]+    f[18];
    m[ 4]  =           -4.f*f[ 1]         +  4.f*f[ 3]         +    f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]         +    f[10]          + -  f[12]                    +    f[15]          + -  f[17]          ;
    m[ 6]  =                    -4.f*f[ 2]         +  4.f*f[ 4]+    f[ 5]+    f[ 6]+ -  f[ 7]+ -  f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];
    m[ 8]  =                                                                                 + -4.f*f[ 9]+    f[10]+    f[11]+    f[12]+    f[13]+  4.f*f[14]+ -  f[15]+ -  f[16]+ -  f[17]+ -  f[18];
    m[ 9]  =            2.f*f[ 1]+ -  f[ 2]+  2.f*f[ 3]+ -  f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+ -  f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[10] =           -4.f*f[ 1]+  2.f*f[ 2]+ -4.f*f[ 3]+  2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+  2.f*f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[11] =                       f[ 2]         +    f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+ -  f[10]          + -  f[12]          + -  f[14]+ -  f[15]          + -  f[17]          ;
    m[12] =                    -2.f*f[ 2]           -2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+ -  f[10]          + -  f[12]          +  2.f*f[14]+ -  f[15]          + -  f[17]          ;
    m[13] =                                                  f[ 5]+ -  f[ 6]+    f[ 7]+ -  f[ 8]                                                                                                   ;
    m[14] =                                                                                                         f[11]          + -  f[13]                    + -  f[16]          +    f[18];
    m[15] =                                                                                               f[10]          + -  f[12]                    + -  f[15]          +    f[17]          ;  
    m[16] =                                                  f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]           -  f[10]          +    f[12]                    + -  f[15]          +    f[17]          ;  
    m[17] =                                               -  f[ 5]+ -  f[ 6]+    f[ 7]+    f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];  
    m[18] =                                                                                               f[10]+ -  f[11]+    f[12]+ -  f[13]          + -  f[15]+    f[16]+ -  f[17]+    f[18];

f[ 0] =(0.052631579f*rho                           +- 0.012531328f*(m[ 1])+ 0.047619048f*(m[ 2]));
f[ 1] =(0.052631579f*rho+  0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+  -0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));
f[ 2] =(0.052631579f*rho         +  0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +   -0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 3] =(0.052631579f*rho+ -0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+   0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));        
f[ 4] =(0.052631579f*rho         + -0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +    0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 5] =(0.052631579f*rho+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 6] =(0.052631579f*rho+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 7] =(0.052631579f*rho+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 8] =(0.052631579f*rho+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 9] =(0.052631579f*rho                  +  0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +   -0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*rho+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*rho         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]+m[ 8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*rho+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*rho         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]-m[ 8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*rho                  + -0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +    0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*rho+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*rho         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]-m[ 8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*rho+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*rho         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]+m[ 8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));

}

inline __device__ void West_Extrap(float* f, float u, int t)
{
    float m[19];
    float v = 0.f;//f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    float w = 0.f;//f[ 9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
    //if(t == 1000 || t == 2000 || t == 3000) w = 0.01f;
    float rho = f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6]+f[7]+f[8]+f[9]+f[10]+f[11]+f[12]+f[13]+f[14]+f[15]+f[16]+f[17]+f[18];

    m[ 1]  = -30.f*f[ 0]+-11.f*f[ 1]+-11.f*f[ 2]+-11.f*f[ 3]+-11.f*f[ 4]+  8.f*f[ 5]+  8.f*f[ 6]+  8.f*f[ 7]+  8.f*f[ 8]+-11.f*f[ 9]+  8.f*f[10]+  8.f*f[11]+  8.f*f[12]+  8.f*f[13]+-11.f*f[14]+  8.f*f[15]+  8.f*f[16]+  8.f*f[17]+  8.f*f[18];
    m[ 2]  =  12.f*f[ 0]+ -4.f*f[ 1]+ -4.f*f[ 2]+ -4.f*f[ 3]+ -4.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -4.f*f[ 9]+    f[10]+      f[11]+    f[12]+    f[13]+ -4.f*f[14]+    f[15]+    f[16]+    f[17]+    f[18];
    m[ 4]  =           -4.f*f[ 1]         +  4.f*f[ 3]         +    f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]         +    f[10]          + -  f[12]                    +    f[15]          + -  f[17]          ;
    m[ 6]  =                    -4.f*f[ 2]         +  4.f*f[ 4]+    f[ 5]+    f[ 6]+ -  f[ 7]+ -  f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];
    m[ 8]  =                                                                                 + -4.f*f[ 9]+    f[10]+    f[11]+    f[12]+    f[13]+  4.f*f[14]+ -  f[15]+ -  f[16]+ -  f[17]+ -  f[18];
    m[ 9]  =            2.f*f[ 1]+ -  f[ 2]+  2.f*f[ 3]+ -  f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+ -  f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[10] =           -4.f*f[ 1]+  2.f*f[ 2]+ -4.f*f[ 3]+  2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+    f[10]+ -2.f*f[11]+    f[12]+ -2.f*f[13]+  2.f*f[14]+    f[15]+ -2.f*f[16]+    f[17]+ -2.f*f[18];
    m[11] =                       f[ 2]         +    f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+ -  f[ 9]+ -  f[10]          + -  f[12]          + -  f[14]+ -  f[15]          + -  f[17]          ;
    m[12] =                    -2.f*f[ 2]           -2.f*f[ 4]+    f[ 5]+    f[ 6]+    f[ 7]+    f[ 8]+  2.f*f[ 9]+ -  f[10]          + -  f[12]          +  2.f*f[14]+ -  f[15]          + -  f[17]          ;
    m[13] =                                                  f[ 5]+ -  f[ 6]+    f[ 7]+ -  f[ 8]                                                                                                   ;
    m[14] =                                                                                                         f[11]          + -  f[13]                    + -  f[16]          +    f[18];
    m[15] =                                                                                               f[10]          + -  f[12]                    + -  f[15]          +    f[17]          ;  
    m[16] =                                                  f[ 5]+ -  f[ 6]+ -  f[ 7]+    f[ 8]           -  f[10]          +    f[12]                    + -  f[15]          +    f[17]          ;  
    m[17] =                                               -  f[ 5]+ -  f[ 6]+    f[ 7]+    f[ 8]                   +    f[11]          + -  f[13]                    +    f[16]          + -  f[18];  
    m[18] =                                                                                               f[10]+ -  f[11]+    f[12]+ -  f[13]          + -  f[15]+    f[16]+ -  f[17]+    f[18];

f[ 0] =(0.052631579f*rho                           +- 0.012531328f*(m[ 1])+ 0.047619048f*(m[ 2]));
f[ 1] =(0.052631579f*rho+  0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+  -0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));
f[ 2] =(0.052631579f*rho         +  0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +   -0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 3] =(0.052631579f*rho+ -0.1f*u                  +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])+   0.1f*(m[ 4])                 + 0.055555556f*((m[ 9])-m[10]));        
f[ 4] =(0.052631579f*rho         + -0.1f*v         +-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])             +    0.1f*(m[ 6])   +-0.027777778f*((m[ 9])-m[10])+ 0.083333333f*((m[11])-m[12]));
f[ 5] =(0.052631579f*rho+  0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 6] =(0.052631579f*rho+ -0.1f*u+  0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]-m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 7] =(0.052631579f*rho+ -0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*(-m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+( 0.25f*(m[13]))));
f[ 8] =(0.052631579f*rho+  0.1f*u+ -0.1f*v         + 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 6])              +0.013888889f*(m[10])+0.041666667f*(m[12])+0.125f*( m[16]+m[17])+ (0.027777778f*(m[ 9]) +0.083333333f*(m[11])+(-0.25f*(m[13]))));
f[ 9] =(0.052631579f*rho                  +  0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +   -0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                       
f[10]=(0.052631579f*rho+  0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[11]=(0.052631579f*rho         +  0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]+m[ 8])+0.125f*( m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));
f[12]=(0.052631579f*rho+ -0.1f*u         +  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]+m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[13]=(0.052631579f*rho         + -0.1f*v+  0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]-m[ 8])+0.125f*(-m[17]-m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[14]=(0.052631579f*rho                  + -0.1f*w+-0.0045948204f*(m[ 1])+-0.015873016f*(m[ 2])                +    0.1f*(m[ 8])+-0.027777778f*((m[ 9])-m[10])+-0.083333333f*((m[11])-m[12]));                                      
f[15]=(0.052631579f*rho+  0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+ 0.025f*(m[ 4]-m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*(-m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+(-0.25f*(m[15]))));
f[16]=(0.052631579f*rho         +  0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             +  0.025f*(m[ 6]-m[ 8])+0.125f*( m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +(-0.25f*(m[14]))));
f[17]=(0.052631579f*rho+ -0.1f*u         + -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])+-0.025f*(m[ 4]+m[ 8])              +0.013888889f*(m[10])-0.041666667f*(m[12])+0.125f*( m[16]-m[18])+ (0.027777778f*(m[ 9]) -0.083333333f*(m[11])+( 0.25f*(m[15]))));
f[18]=(0.052631579f*rho         + -0.1f*v+ -0.1f*w+ 0.0033416876f*(m[ 1])+ 0.003968254f*(m[ 2])             + -0.025f*(m[ 6]+m[ 8])+0.125f*(-m[17]+m[18])-0.027777778f*(m[10])+(-0.055555556f*(m[ 9]) +( 0.25f*(m[14]))));

}


__device__ void xsymmetry_bot(float* f, int y, int z)
{
    if(y == 0 && z == 0){
        f[ 2] = f[ 4];
        f[13]=f[18];
        f[11]=f[18];
        f[16]=f[18];
        f[ 6] =f[ 7];
        f[ 9] =f[14];
        f[12]=f[17];
    }
    else if(y == 0 && z == ZDIM-1){
        f[ 4] = f[ 2];
        f[11]=f[13];
        f[18]=f[13];
        f[16]=f[13];
        f[ 6] =f[ 7];
        f[14]=f[ 9];
        f[17]=f[12];
    }
    else if(y == YDIM-1 && z == 0){
        f[ 4] = f[ 2];
        f[11]=f[16];
        f[18]=f[16];
        f[13]=f[16];
        f[ 7] =f[ 6];
        f[ 9] =f[14];
        f[12]=f[17];
    }
    else if(y == YDIM-1 && z == ZDIM-1){
        f[ 4] = f[ 2];
        f[16]=f[11];
        f[18]=f[11];
        f[13]=f[11];
        f[ 7] =f[ 6];
        f[14]=f[ 9];
        f[17]=f[12];
    }
    else{
    if(y == 0){
        f[ 2] = f[ 4];
        f[11]=f[13];
        f[16]=f[18];
        f[ 8] = f[ 5];
    }
    else if(y == YDIM-1){
         f[ 4]=f[ 2] ;
        f[13]=f[11];
        f[18]=f[16];
         f[ 5]=f[ 8] ;
    }
    }
    f[ 1] = f[ 3] ;
    f[ 5] = f[ 6] ;
    f[ 8] = f[ 7] ;
    f[10]= f[12];
    f[15]= f[17];
}

__device__ void xsymmetry_top(float* f, int y, int z)
{
    if(y == 0 && z == 0){
        f[ 2]  = f[ 4];
        f[13] = f[18];            
        f[11] = f[18];
        f[16] = f[18];
        f[ 5]  = f[ 8];
        f[ 9]  = f[14];
        f[10] = f[15];
    }
    else if(y == 0 && z == ZDIM-1){
        f[ 2]  = f[ 4];
        f[11] = f[13];
        f[18] = f[13];
        f[16] = f[13];
        f[ 5]  = f[ 8];
        f[14] = f[ 9];
        f[15] = f[10];
    }
    else if(y == YDIM-1 && z == 0){
        f[ 4]  = f[ 2];
        f[18] = f[16];
        f[11] = f[16];
        f[13] = f[16];    
        f[ 8]  = f[ 5];
        f[ 9]  = f[14];
        f[10] = f[15];
    }
    else if(y == YDIM-1 && z == ZDIM-1){
        f[ 4]  = f[ 2];
        f[13] = f[11];
        f[16] = f[11];
        f[18] = f[11];
        f[ 8]  = f[ 5];
        f[14] = f[ 9];
        f[15] = f[10];
    }

    else{
    if(y == 0){
        f[ 2] = f[ 4];
        f[11] = f[13];
        f[16] = f[18];
        f[ 5] = f[ 8];
    }
    else if(y == YDIM-1){
        f[ 4] = f[ 2];
        f[13] = f[11];
        f[18] = f[16];
        f[ 8] = f[ 5];
    }
    }
    f[ 3] = f[ 1] ;
    f[ 6] = f[ 5] ;
    f[ 7] = f[ 8] ;
    f[12]= f[10];
    f[17]= f[15];
}

inline __device__ void vel_av(float* f, float& uAv, float& vAv, int t)
{
    float u,v;//,w;    
    u = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    v = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    uAv = (uAv*(t-START_VELAV)+u)/((t-START_VELAV)+1);
    vAv = (vAv*(t-START_VELAV)+v)/((t-START_VELAV)+1);
}

inline __device__ void vel_avLR(float* f, float& uAv, float& vAv, float t)
{
    float u,v;//,w;    
    u = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    v = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    uAv = (uAv*(t-START_VELAV)+u*LRFACTOR)/((t-START_VELAV)+LRFACTOR);
    vAv = (vAv*(t-START_VELAV)+v*LRFACTOR)/((t-START_VELAV)+LRFACTOR);
}

inline __device__ void vel_fluc(float* f, float& uAv, 
                    float& vAv, float& ufluc, float& vfluc, int t)
{
    float u,v;//,w;    
    u = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    v = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    u = (u-uAv)*(u-uAv);
    v = (v-vAv)*(v-vAv);
    ufluc = (ufluc*(t-START_VELFLUC)+u)/((t-START_VELFLUC)+1);
    vfluc = (vfluc*(t-START_VELFLUC)+v)/((t-START_VELFLUC)+1);
}

inline __device__ void vel_flucLR(float* f, float& uAv, 
                    float& vAv, float& ufluc, float& vfluc, float t)
{
    float u,v;//,w;    
    u = f[ 1]-f[ 3]+f[ 5]-f[ 6]-f[ 7]+f[ 8]+f[10]-f[12]+f[15]-f[17];
    v = f[ 2]-f[ 4]+f[ 5]+f[ 6]-f[ 7]-f[ 8]+f[11]-f[13]+f[16]-f[18];
    u = (u-uAv)*(u-uAv);
    v = (v-vAv)*(v-vAv);
    ufluc = (ufluc*(t-START_VELFLUC)+u*LRFACTOR)/((t-START_VELFLUC)+LRFACTOR);
    vfluc = (vfluc*(t-START_VELFLUC)+v*LRFACTOR)/((t-START_VELFLUC)+LRFACTOR);
}

__global__ void initialize(float *fout, size_t pitch, int zInner, int GPU_N)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
    float xcoord = x;
    float ycoord = y;
    float zcoord = z+1+GPU_N*ZDIM;
    int j = x+y*pitch+z*YDIM*pitch;//index on padded mem (pitch in elements)
    float f[19] = {0};
    float m[19] = {0};
    
    int im = ImageFcn(xcoord,ycoord,zcoord,0);
    float u,v,w,rho;
    rho = 1.f;
    u = 0.0f;
    v = UMAX;
    w = 0.0f;

    if(im == 10 || im == 1){
    u = 0.0f;
    v = 0.0f;
    w = 0.0f;
    }
    
    mrt_meq(m,rho,u,v,w);
    InvertMoments(f,m);
    
    for(int i = 0; i<19; i++)
    fout[j+i *pitch*YDIM*zInner]=f[ i];
}

__global__ void initializeLR(float *fout, size_t pitch, int zInner, int GPU_N)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
    float xcoord = x;
    float ycoord = y;
    float zcoord = z+1+GPU_N*(zInner+2);
    xcoord = LRX0+x*LRFACTOR;
    ycoord = LRY0+y*LRFACTOR;
    zcoord = LRZ0+LRFACTOR*(GPU_N*(zInner+2)+z);
    int j = x+y*pitch+z*YLRDIM*pitch;//index on padded mem (pitch in elements)
    float f[19] = {0};
    float m[19] = {0};
    
    int im = ImageFcnLR(xcoord,ycoord,zcoord);
    float u,v,w,rho;
    rho = 1.f;
    u = UMAX;
    v = 0.0f;
    w = 0.0f;

    if(im == 10 || im == 1){
    u = 0.0f;
    v = 0.0f;
    w = 0.0f;
    }
    
    mrt_meq(m,rho,u,v,w);
    InvertMoments(f,m);
    
    for(int i = 0; i<19; i++)
    fout[j+i *pitch*YLRDIM*zInner]=f[ i];
}

__global__ void update_top(float* hB, float* hA, float* fA, float* temp,
                            float omega, size_t pitch, int GPU, int zInner, float* FX, float* FY, float* FZ, int t, int flag_F, float* h_interp, size_t pitch_interp, float dpdy)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int j = x+y*pitch;//index on padded mem (pitch in elements)
    int im = ImageFcn(x,y,(GPU+1)*(zInner+2)-1,t);
    float f[19];
    __shared__ float sumX[BLOCKSIZEX], sumY[BLOCKSIZEX], sumZ[BLOCKSIZEX];
    __shared__ int check[1];
    check[0] = 0;
    syncthreads();

    f[0 ]= hA  [j];
    f[1 ]= hA  [buff_mem(1 ,x-1,y  ,pitch)];
    f[3 ]= hA  [buff_mem(3 ,x+1,y  ,pitch)];
    f[2 ]= hA  [buff_mem(2 ,x  ,y-1,pitch)];
    f[5 ]= hA  [buff_mem(5 ,x-1,y-1,pitch)];
    f[6 ]= hA  [buff_mem(6 ,x+1,y-1,pitch)];
    f[4 ]= hA  [buff_mem(4 ,x  ,y+1,pitch)];
    f[7 ]= hA  [buff_mem(7 ,x+1,y+1,pitch)];
    f[8 ]= hA  [buff_mem(8 ,x-1,y+1,pitch)];
    f[9 ]= fA  [f_mem   (9 ,x  ,y  ,zInner-1,pitch, zInner)];
    f[10]= fA  [f_mem   (10,x-1,y  ,zInner-1,pitch, zInner)];
    f[11]= fA  [f_mem   (11,x  ,y-1,zInner-1,pitch, zInner)];
    f[12]= fA  [f_mem   (12,x+1,y  ,zInner-1,pitch, zInner)];
    f[13]= fA  [f_mem   (13,x  ,y+1,zInner-1,pitch, zInner)];
    f[14]= temp[buff_mem(14,x  ,y  ,pitch)];
    f[15]= temp[buff_mem(15,x-1,y  ,pitch)];
    f[16]= temp[buff_mem(16,x  ,y-1,pitch)];
    f[17]= temp[buff_mem(17,x+1,y  ,pitch)];
    f[18]= temp[buff_mem(18,x  ,y+1,pitch)];

    if(im == 1 || im ==10){//BB
        if(im == 10 && flag_F == 1){
        check[0] = 1;
        sumX[threadIdx.x]=2.f*f[ 1]-2.f*f[ 3]+2.f*f[ 5]+2.f*f[ 8]-2.f*f[ 6];
        sumX[threadIdx.x]+=-2.f*f[ 7]+2.f*f[10]-2.f*f[12]+2.f*f[15]-2.f*f[17];
        sumY[threadIdx.x]=2.f*f[ 2]-2.f*f[ 4]+2.f*f[ 5]-2.f*f[ 8]+2.f*f[ 6];
        sumY[threadIdx.x]+=-2.f*f[ 7]+2.f*f[11]-2.f*f[13]+2.f*f[16]-2.f*f[18];
        sumZ[threadIdx.x]=2.f*f[ 9]+2.f*f[10]+2.f*f[11]+2.f*f[12]+2.f*f[13];
        sumZ[threadIdx.x]+=-2.f*f[14]-2.f*f[15]-2.f*f[16]-2.f*f[17]-2.f*f[18];
        }
        else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        }
        hB[buff_mem(0 ,x,y,pitch)] = f[0 ];
        hB[buff_mem(1 ,x,y,pitch)] = f[3 ];
        hB[buff_mem(2 ,x,y,pitch)] = f[4 ];
        hB[buff_mem(3 ,x,y,pitch)] = f[1 ];
        hB[buff_mem(4 ,x,y,pitch)] = f[2 ];
        hB[buff_mem(5 ,x,y,pitch)] = f[7 ];
        hB[buff_mem(6 ,x,y,pitch)] = f[8 ];
        hB[buff_mem(7 ,x,y,pitch)] = f[5 ];
        hB[buff_mem(8 ,x,y,pitch)] = f[6 ];
        hB[buff_mem(9 ,x,y,pitch)] = f[14];
        hB[buff_mem(10,x,y,pitch)] = f[17];
        hB[buff_mem(11,x,y,pitch)] = f[18];
        hB[buff_mem(12,x,y,pitch)] = f[15];
        hB[buff_mem(13,x,y,pitch)] = f[16];
        hB[buff_mem(14,x,y,pitch)] = f[9 ];
        hB[buff_mem(15,x,y,pitch)] = f[12];
        hB[buff_mem(16,x,y,pitch)] = f[13];
        hB[buff_mem(17,x,y,pitch)] = f[10];
        hB[buff_mem(18,x,y,pitch)] = f[11];
    }
    else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        if(im == 100)//north outlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,x,y-1,pitch)];
            North_Extrap(f,1.0f);
        }
        if(im == 200)//south inlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,x,y+1,pitch)];
            //South_Extrap(f,UMAX);
            float u_in = PoisProf3D(x,(GPU+1)*(zInner+2)-1);
            South_Extrap(f,u_in);
        }
        if(im == 300)//east outlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,x-1,y,pitch)];
            East_Extrap(f,1.0f);
        }
        if(im == 400)//west inlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,x+1,y,pitch)];
            float u_in = PoisProf3D(y,(GPU+1)*(zInner+2)-1);
            West_Extrap(f,u_in,t);
        }

        if(im == 25)
            xsymmetry_top(f,y,(GPU+1)*(zInner+2)-1);
        if(im == 26)
            xsymmetry_bot(f,y,(GPU+1)*(zInner+2)-1);

        mrt_collide(f,omega,dpdy);

        if(im == 50)//west periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,XDIM-2,y,pitch)];
        }
        if(im == 51)//east periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,1,y,pitch)];
        }
        if(im == 52)//south periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,x,YDIM-2,pitch)];
        }
        if(im == 53)//north periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= hA[buff_mem(i ,x,1,pitch)];
        }
        for(int i = 0; i<19; i++)
            hB[buff_mem(i ,x,y,pitch)] = f[i ];



    }

        if(REFINEMENT == 1){
        if(x>=int(LRX0)&&x<=int(LRX0+XLRDIM*LRFACTOR)&&y>=int(LRY0)&&y<=int(LRY0+YLRDIM*LRFACTOR))
        {
//        if(x>int(LRX0+2)&&x<int(LRX0+XLRDIM*LRFACTOR-1)&&y>int(LRY0+2)&&y<int(LRY0+YLRDIM*LRFACTOR-1))
//        {
//        //do nothing
//        }
//        else{
//            //float rho,u,v,w,m9,m11,m13,m14,m15;
            float mom[9];
            PhysicalMoments(mom,f);
            for(int i = 0; i<9; i++)
                h_interp[buff_mem_interp(i,x-int(LRX0),y-int(LRY0),pitch_interp,zInner)]=mom[i];
//        }
        }
        }

    syncthreads();
    if(check[0] == 1){
    //reduction for force
    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumX[threadIdx.x] += sumX[threadIdx.x+halfPoint];
            sumY[threadIdx.x] += sumY[threadIdx.x+halfPoint];
            sumZ[threadIdx.x] += sumZ[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&FX[t-STARTF],sumX[0]);
        atomicAdd(&FY[t-STARTF],sumY[0]);
        atomicAdd(&FZ[t-STARTF],sumZ[0]);
    }
    }

}

__global__ void update_bot(float* gB, float* gA, float* fA, float* temp,
                            float omega, size_t pitch, int GPU, int zInner, float* FX, float* FY, float* FZ, int t, int flag_F, float* g_interp, size_t pitch_interp, float dpdy)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int j = x+y*pitch;//index on padded mem (pitch in elements)
    int im = ImageFcn(x,y,GPU*(zInner+2),t);
    float f[19];
    __shared__ float sumX[BLOCKSIZEX], sumY[BLOCKSIZEX], sumZ[BLOCKSIZEX];
    __shared__ int check[1];
    check[0] = 0;
    syncthreads();

    f[0 ]= gA  [j];
    f[1 ]= gA  [buff_mem(1 ,x-1,y  ,pitch)];
    f[3 ]= gA  [buff_mem(3 ,x+1,y  ,pitch)];
    f[2 ]= gA  [buff_mem(2 ,x  ,y-1,pitch)];
    f[5 ]= gA  [buff_mem(5 ,x-1,y-1,pitch)];
    f[6 ]= gA  [buff_mem(6 ,x+1,y-1,pitch)];
    f[4 ]= gA  [buff_mem(4 ,x  ,y+1,pitch)];
    f[7 ]= gA  [buff_mem(7 ,x+1,y+1,pitch)];
    f[8 ]= gA  [buff_mem(8 ,x-1,y+1,pitch)];
    f[9 ]= temp[buff_mem(9 ,x  ,y  ,pitch)];
    f[10]= temp[buff_mem(10,x-1,y  ,pitch)];
    f[11]= temp[buff_mem(11,x  ,y-1,pitch)];
    f[12]= temp[buff_mem(12,x+1,y  ,pitch)];
    f[13]= temp[buff_mem(13,x  ,y+1,pitch)];
    f[14]= fA  [f_mem   (14,x  ,y  ,0,pitch, zInner)];
    f[15]= fA  [f_mem   (15,x-1,y  ,0,pitch, zInner)];
    f[16]= fA  [f_mem   (16,x  ,y-1,0,pitch, zInner)];
    f[17]= fA  [f_mem   (17,x+1,y  ,0,pitch, zInner)];
    f[18]= fA  [f_mem   (18,x  ,y+1,0,pitch, zInner)];

    if(im == 1 || im ==10){//BB
        if(im == 10 && flag_F == 1){
        check[0] = 1;
        sumX[threadIdx.x]=2.f*f[ 1]-2.f*f[ 3]+2.f*f[ 5]+2.f*f[ 8]-2.f*f[ 6];
        sumX[threadIdx.x]+=-2.f*f[ 7]+2.f*f[10]-2.f*f[12]+2.f*f[15]-2.f*f[17];
        sumY[threadIdx.x]=2.f*f[ 2]-2.f*f[ 4]+2.f*f[ 5]-2.f*f[ 8]+2.f*f[ 6];
        sumY[threadIdx.x]+=-2.f*f[ 7]+2.f*f[11]-2.f*f[13]+2.f*f[16]-2.f*f[18];
        sumZ[threadIdx.x]=2.f*f[ 9]+2.f*f[10]+2.f*f[11]+2.f*f[12]+2.f*f[13];
        sumZ[threadIdx.x]+=-2.f*f[14]-2.f*f[15]-2.f*f[16]-2.f*f[17]-2.f*f[18];
        }
        else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        }
        gB[buff_mem(0 ,x,y,pitch)] = f[0 ];
        gB[buff_mem(1 ,x,y,pitch)] = f[3 ];
        gB[buff_mem(2 ,x,y,pitch)] = f[4 ];
        gB[buff_mem(3 ,x,y,pitch)] = f[1 ];
        gB[buff_mem(4 ,x,y,pitch)] = f[2 ];
        gB[buff_mem(5 ,x,y,pitch)] = f[7 ];
        gB[buff_mem(6 ,x,y,pitch)] = f[8 ];
        gB[buff_mem(7 ,x,y,pitch)] = f[5 ];
        gB[buff_mem(8 ,x,y,pitch)] = f[6 ];
        gB[buff_mem(9 ,x,y,pitch)] = f[14];
        gB[buff_mem(10,x,y,pitch)] = f[17];
        gB[buff_mem(11,x,y,pitch)] = f[18];
        gB[buff_mem(12,x,y,pitch)] = f[15];
        gB[buff_mem(13,x,y,pitch)] = f[16];
        gB[buff_mem(14,x,y,pitch)] = f[9 ];
        gB[buff_mem(15,x,y,pitch)] = f[12];
        gB[buff_mem(16,x,y,pitch)] = f[13];
        gB[buff_mem(17,x,y,pitch)] = f[10];
        gB[buff_mem(18,x,y,pitch)] = f[11];
    }
    else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        if(im == 100)//north outlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,x,y-1,pitch)];
            North_Extrap(f,1.0f);
        }
        if(im == 200)//south inlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,x,y+1,pitch)];
            //South_Extrap(f,UMAX);
            float u_in = PoisProf3D(x,GPU*(zInner+2));
            South_Extrap(f,u_in);
        }
        if(im == 300)//east outlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,x-1,y,pitch)];
            East_Extrap(f,1.0f);
        }
        if(im == 400)//west inlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,x+1,y,pitch)];
            float u_in = PoisProf3D(y,GPU*(zInner+2));
            West_Extrap(f,u_in,t);
        }

        if(im == 25)
            xsymmetry_top(f,y,GPU*(zInner+2));
        if(im == 26)
            xsymmetry_bot(f,y,GPU*(zInner+2));

        mrt_collide(f,omega,dpdy);

        if(im == 50)//west periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,XDIM-2,y,pitch)];
        }
        if(im == 51)//east periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,1,y,pitch)];
        }
        if(im == 52)//south periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,x,YDIM-2,pitch)];
        }
        if(im == 53)//north periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= gA[buff_mem(i ,x,1,pitch)];
        }
        for(int i = 0; i<19; i++)
            gB[buff_mem(i ,x,y,pitch)] = f[i ];


    }


        if(REFINEMENT == 1){
        if(x>=int(LRX0)&&x<=int(LRX0+XLRDIM*LRFACTOR)&&y>=int(LRY0)&&y<=int(LRY0+YLRDIM*LRFACTOR))
        {
//        if(x>int(LRX0+2)&&x<int(LRX0+XLRDIM*LRFACTOR-1)&&y>int(LRY0+2)&&y<int(LRY0+YLRDIM*LRFACTOR-1))
//        {
//        //do nothing
//        }
//        else{
            //float rho,u,v,w,m9,m11,m13,m14,m15;
            float mom[9];
            PhysicalMoments(mom,f);
            for(int i = 0; i<9; i++)
                g_interp[buff_mem_interp(i,x-int(LRX0),y-int(LRY0),pitch_interp,zInner)]=mom[i];
//        }
        }
        }

    syncthreads();
    if(check[0] == 1){
    //reduction for force
    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumX[threadIdx.x] += sumX[threadIdx.x+halfPoint];
            sumY[threadIdx.x] += sumY[threadIdx.x+halfPoint];
            sumZ[threadIdx.x] += sumZ[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&FX[t-STARTF],sumX[0]);
        atomicAdd(&FY[t-STARTF],sumY[0]);
        atomicAdd(&FZ[t-STARTF],sumZ[0]);
    }
    }
}

__global__ void update_inn(float* fB, float* fA, float* g, float* h, float omega, size_t pitch, int GPU, int zInner, float* velAv_u, float* velAv_v, float* velFluc_u, float* velFluc_v, float* FX, float* FY, float* FZ, int t, int flag_F, float* f_interp, size_t pitch_interp, float dpdy)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
    int j = x+y*pitch+z*YDIM*pitch;//index on padded mem (pitch in elements)
    int im = ImageFcn(x,y,GPU*(zInner+2)+1+z,t);
    float f[19];
    __shared__ float sumX[BLOCKSIZEX], sumY[BLOCKSIZEX], sumZ[BLOCKSIZEX];
    __shared__ int check[1];
    check[0] = 0;
    syncthreads();

    f[ 0] = fA[j];
    f[ 1] = fA[f_mem   (1 ,x-1,y  ,z  ,pitch, zInner)];
    f[ 3] = fA[f_mem   (3 ,x+1,y  ,z  ,pitch, zInner)];
    f[ 2] = fA[f_mem   (2 ,x  ,y-1,z  ,pitch, zInner)];
    f[ 5] = fA[f_mem   (5 ,x-1,y-1,z  ,pitch, zInner)];
    f[ 6] = fA[f_mem   (6 ,x+1,y-1,z  ,pitch, zInner)];
    f[ 4] = fA[f_mem   (4 ,x  ,y+1,z  ,pitch, zInner)];
    f[ 7] = fA[f_mem   (7 ,x+1,y+1,z  ,pitch, zInner)];
    f[ 8] = fA[f_mem   (8 ,x-1,y+1,z  ,pitch, zInner)];

    if(z==zInner-1){//top nodes need info from h
    f[ 9] = fA[f_mem   (9 ,x  ,y  ,z-1,pitch, zInner)];
    f[10]= fA[f_mem   (10,x-1,y  ,z-1,pitch, zInner)];
    f[11]= fA[f_mem   (11,x  ,y-1,z-1,pitch, zInner)];
    f[12]= fA[f_mem   (12,x+1,y  ,z-1,pitch, zInner)];
    f[13]= fA[f_mem   (13,x  ,y+1,z-1,pitch, zInner)];
    f[14]= h [buff_mem(14,x  ,y  ,pitch)];
    f[15]= h [buff_mem(15,x-1,y  ,pitch)];
    f[16]= h [buff_mem(16,x  ,y-1,pitch)];
    f[17]= h [buff_mem(17,x+1,y  ,pitch)];
    f[18]= h [buff_mem(18,x  ,y+1,pitch)];
    }
    else if(z==0){//bottom nodes need info from g
    f[ 9] =g [buff_mem(9 ,x  ,y  ,pitch)];
    f[10]= g [buff_mem(10,x-1,y  ,pitch)];
    f[11]= g [buff_mem(11,x  ,y-1,pitch)];
    f[12]= g [buff_mem(12,x+1,y  ,pitch)];
    f[13]= g [buff_mem(13,x  ,y+1,pitch)];
    f[14]= fA[f_mem   (14,x  ,y  ,z+1,pitch, zInner)];
    f[15]= fA[f_mem   (15,x-1,y  ,z+1,pitch, zInner)];
    f[16]= fA[f_mem   (16,x  ,y-1,z+1,pitch, zInner)];
    f[17]= fA[f_mem   (17,x+1,y  ,z+1,pitch, zInner)];
    f[18]= fA[f_mem   (18,x  ,y+1,z+1,pitch, zInner)];
    }
    else{//normal nodes
    f[ 9] = fA[f_mem(9 ,x  ,y  ,z-1,pitch,zInner)];
    f[10]= fA[f_mem(10,x-1,y  ,z-1,pitch,zInner)];
    f[11]= fA[f_mem(11,x  ,y-1,z-1,pitch,zInner)];
    f[12]= fA[f_mem(12,x+1,y  ,z-1,pitch,zInner)];
    f[13]= fA[f_mem(13,x  ,y+1,z-1,pitch,zInner)];
    f[14]= fA[f_mem(14,x  ,y  ,z+1,pitch,zInner)];
    f[15]= fA[f_mem(15,x-1,y  ,z+1,pitch,zInner)];
    f[16]= fA[f_mem(16,x  ,y-1,z+1,pitch,zInner)];
    f[17]= fA[f_mem(17,x+1,y  ,z+1,pitch,zInner)];
    f[18]= fA[f_mem(18,x  ,y+1,z+1,pitch,zInner)];

    }//end normal nodes

    if(im == 1 || im ==10){//BB
        if(im == 10 && flag_F == 1){
        check[0] = 1;
        sumX[threadIdx.x]=2.f*f[ 1]-2.f*f[ 3]+2.f*f[ 5]+2.f*f[ 8]-2.f*f[ 6];
        sumX[threadIdx.x]+=-2.f*f[ 7]+2.f*f[10]-2.f*f[12]+2.f*f[15]-2.f*f[17];
        sumY[threadIdx.x]=2.f*f[ 2]-2.f*f[ 4]+2.f*f[ 5]-2.f*f[ 8]+2.f*f[ 6];
        sumY[threadIdx.x]+=-2.f*f[ 7]+2.f*f[11]-2.f*f[13]+2.f*f[16]-2.f*f[18];
        sumZ[threadIdx.x]=2.f*f[ 9]+2.f*f[10]+2.f*f[11]+2.f*f[12]+2.f*f[13];
        sumZ[threadIdx.x]+=-2.f*f[14]-2.f*f[15]-2.f*f[16]-2.f*f[17]-2.f*f[18];
        }
        else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        }
        fB[f_mem(1 ,x,y,z,pitch,zInner)] = f[ 3] ;
        fB[f_mem(2 ,x,y,z,pitch,zInner)] = f[ 4] ;
        fB[f_mem(3 ,x,y,z,pitch,zInner)] = f[ 1] ;
        fB[f_mem(4 ,x,y,z,pitch,zInner)] = f[ 2] ;
        fB[f_mem(5 ,x,y,z,pitch,zInner)] = f[ 7] ;
        fB[f_mem(6 ,x,y,z,pitch,zInner)] = f[ 8] ;
        fB[f_mem(7 ,x,y,z,pitch,zInner)] = f[ 5] ;
        fB[f_mem(8 ,x,y,z,pitch,zInner)] = f[ 6] ;
        fB[f_mem(9 ,x,y,z,pitch,zInner)] = f[14];
        fB[f_mem(10,x,y,z,pitch,zInner)] = f[17];
        fB[f_mem(11,x,y,z,pitch,zInner)] = f[18];
        fB[f_mem(12,x,y,z,pitch,zInner)] = f[15];
        fB[f_mem(13,x,y,z,pitch,zInner)] = f[16];
        fB[f_mem(14,x,y,z,pitch,zInner)] = f[ 9] ;
        fB[f_mem(15,x,y,z,pitch,zInner)] = f[12];
        fB[f_mem(16,x,y,z,pitch,zInner)] = f[13];
        fB[f_mem(17,x,y,z,pitch,zInner)] = f[10];
        fB[f_mem(18,x,y,z,pitch,zInner)] = f[11];
    }
    else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        if(im == 100)//north outlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,x,y-1,z,pitch,zInner)];
            North_Extrap(f,1.0f);
        }
        if(im == 200)//south inlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,x,y+1,z,pitch,zInner)];
            //South_Extrap(f,UMAX);
            float u_in = PoisProf3D(x,GPU*(zInner+2)+1+z);
            South_Extrap(f,u_in);
        }
        if(im == 300)//east outlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,x-1,y,z,pitch,zInner)];
            East_Extrap(f,1.0f);
        }
        if(im == 400)//west inlet
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,x+1,y,z,pitch,zInner)];
            float u_in = PoisProf3D(y,GPU*(zInner+2)+1+z);
            West_Extrap(f,u_in,t);
        }

        if(im == 25)
            xsymmetry_top(f,y,GPU*(zInner+2)+1+z);
        if(im == 26)
            xsymmetry_bot(f,y,GPU*(zInner+2)+1+z);

        mrt_collide(f,omega,dpdy);
        
        if(im == 50)//west periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,XDIM-2,y,z,pitch,zInner)];
        }
        if(im == 51)//east periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,1,y,z,pitch,zInner)];
        }
        if(im == 52)//south periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,x,YDIM-2,z,pitch,zInner)];
        }
        if(im == 53)//north periodic
        {
            for(int i = 0; i<19; i++)
                   f[i ]= fA[f_mem(i ,x,1,z,pitch,zInner)];
        }

        if(VELAV == 1){
            if(t>=START_VELAV && t<START_VELFLUC){
                float u_Av = velAv_u[x+y*pitch+(z+1)*pitch*YDIM];
                float v_Av = velAv_v[x+y*pitch+(z+1)*pitch*YDIM];
                vel_av(f,u_Av,v_Av,t);
                velAv_u[x+y*pitch+(z+1)*pitch*YDIM] = u_Av;
                velAv_v[x+y*pitch+(z+1)*pitch*YDIM] = v_Av;
            }
            else if(t>=START_VELFLUC){
                float u_Av = velAv_u[x+y*pitch+(z+1)*pitch*YDIM];
                float v_Av = velAv_v[x+y*pitch+(z+1)*pitch*YDIM];
                float u_fluc = velFluc_u[x+y*pitch+(z+1)*pitch*YDIM];
                float v_fluc = velFluc_v[x+y*pitch+(z+1)*pitch*YDIM];
                vel_fluc(f,u_Av,v_Av,u_fluc,v_fluc,t);
                velFluc_u[x+y*pitch+(z+1)*pitch*YDIM] = u_fluc;
                velFluc_v[x+y*pitch+(z+1)*pitch*YDIM] = v_fluc;
            }
        }

        for(int i = 0; i<19; i++)
            fB[f_mem(i ,x,y,z,pitch,zInner)] = f[ i] ;
    }

        if(REFINEMENT == 1){
        if(x>=int(LRX0)&&x<=int(LRX0+XLRDIM*LRFACTOR)&&y>=int(LRY0)&&y<=int(LRY0+YLRDIM*LRFACTOR))
        {
//        if(x>int(LRX0+2)&&x<int(LRX0+XLRDIM*LRFACTOR-1)&&y>int(LRY0+2)&&y<int(LRY0+YLRDIM*LRFACTOR-1))
//        {
//        //do nothing
//        }
//        else{
            //float rho,u,v,w,m9,m11,m13,m14,m15;
            float mom[9];
            PhysicalMoments(mom,f);
            for(int i = 0; i<9; i++)
                f_interp[f_mem_interp(i,x-int(LRX0),y-int(LRY0),z,pitch_interp,zInner)]=mom[i];
//        }
        }
        }

    syncthreads();
    if(check[0] == 1){
    //reduction for force
    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumX[threadIdx.x] += sumX[threadIdx.x+halfPoint];
            sumY[threadIdx.x] += sumY[threadIdx.x+halfPoint];
            sumZ[threadIdx.x] += sumZ[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&FX[t-STARTF],sumX[0]);
        atomicAdd(&FY[t-STARTF],sumY[0]);
        atomicAdd(&FZ[t-STARTF],sumZ[0]);
    }
    }

}

__global__ void update_top_LR(float* hB, float* hA, float* fA, float* temp,
                            float omega, size_t pitch, int GPU, int zInner, float* FX, float* FY, float* FZ, int t, int flag_F)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = (GPU+1)*(zInner+2)-1;//physical coord in LR region
    int j = x+y*pitch;//index on padded mem (pitch in elements)
    float xcoord = LRX0+x*LRFACTOR;
	float ycoord = LRY0+y*LRFACTOR;
	float zcoord = LRZ0+LRFACTOR*z;
	int im = ImageFcnLR(xcoord,ycoord,zcoord);
    float f[19];
    __shared__ float sumX[BLOCKSIZELRX], sumY[BLOCKSIZELRX], sumZ[BLOCKSIZELRX];
    __shared__ int check[1];
    check[0] = 0;
    syncthreads();

    f[0 ]= hA  [j];
    f[1 ]= hA  [buff_memLR(1 ,x-1,y  ,pitch)];
    f[3 ]= hA  [buff_memLR(3 ,x+1,y  ,pitch)];
    f[2 ]= hA  [buff_memLR(2 ,x  ,y-1,pitch)];
    f[5 ]= hA  [buff_memLR(5 ,x-1,y-1,pitch)];
    f[6 ]= hA  [buff_memLR(6 ,x+1,y-1,pitch)];
    f[4 ]= hA  [buff_memLR(4 ,x  ,y+1,pitch)];
    f[7 ]= hA  [buff_memLR(7 ,x+1,y+1,pitch)];
    f[8 ]= hA  [buff_memLR(8 ,x-1,y+1,pitch)];
    f[9 ]= fA  [   f_memLR(9 ,x  ,y  ,zInner-1,pitch, zInner)];
    f[10]= fA  [   f_memLR(10,x-1,y  ,zInner-1,pitch, zInner)];
    f[11]= fA  [   f_memLR(11,x  ,y-1,zInner-1,pitch, zInner)];
    f[12]= fA  [   f_memLR(12,x+1,y  ,zInner-1,pitch, zInner)];
    f[13]= fA  [   f_memLR(13,x  ,y+1,zInner-1,pitch, zInner)];
    f[14]= temp[buff_memLR(14,x  ,y  ,pitch)];
    f[15]= temp[buff_memLR(15,x-1,y  ,pitch)];
    f[16]= temp[buff_memLR(16,x  ,y-1,pitch)];
    f[17]= temp[buff_memLR(17,x+1,y  ,pitch)];
    f[18]= temp[buff_memLR(18,x  ,y+1,pitch)];

    if(im == 1 || im ==10){//BB
        if(im == 10 && flag_F == 1){
        check[0] = 1;
        sumX[threadIdx.x]=2.f*f[ 1]-2.f*f[ 3]+2.f*f[ 5]+2.f*f[ 8]-2.f*f[ 6];
        sumX[threadIdx.x]+=-2.f*f[ 7]+2.f*f[10]-2.f*f[12]+2.f*f[15]-2.f*f[17];
        sumY[threadIdx.x]=2.f*f[ 2]-2.f*f[ 4]+2.f*f[ 5]-2.f*f[ 8]+2.f*f[ 6];
        sumY[threadIdx.x]+=-2.f*f[ 7]+2.f*f[11]-2.f*f[13]+2.f*f[16]-2.f*f[18];
        sumZ[threadIdx.x]=2.f*f[ 9]+2.f*f[10]+2.f*f[11]+2.f*f[12]+2.f*f[13];
        sumZ[threadIdx.x]+=-2.f*f[14]-2.f*f[15]-2.f*f[16]-2.f*f[17]-2.f*f[18];
        }
        else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        }
        hB[buff_memLR(0 ,x,y,pitch)] = f[0 ];
        hB[buff_memLR(1 ,x,y,pitch)] = f[3 ];
        hB[buff_memLR(2 ,x,y,pitch)] = f[4 ];
        hB[buff_memLR(3 ,x,y,pitch)] = f[1 ];
        hB[buff_memLR(4 ,x,y,pitch)] = f[2 ];
        hB[buff_memLR(5 ,x,y,pitch)] = f[7 ];
        hB[buff_memLR(6 ,x,y,pitch)] = f[8 ];
        hB[buff_memLR(7 ,x,y,pitch)] = f[5 ];
        hB[buff_memLR(8 ,x,y,pitch)] = f[6 ];
        hB[buff_memLR(9 ,x,y,pitch)] = f[14];
        hB[buff_memLR(10,x,y,pitch)] = f[17];
        hB[buff_memLR(11,x,y,pitch)] = f[18];
        hB[buff_memLR(12,x,y,pitch)] = f[15];
        hB[buff_memLR(13,x,y,pitch)] = f[16];
        hB[buff_memLR(14,x,y,pitch)] = f[9 ];
        hB[buff_memLR(15,x,y,pitch)] = f[12];
        hB[buff_memLR(16,x,y,pitch)] = f[13];
        hB[buff_memLR(17,x,y,pitch)] = f[10];
        hB[buff_memLR(18,x,y,pitch)] = f[11];
    }
    else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;

        mrt_collide(f,omega,LRFACTOR);

        for(int i = 0; i<19; i++)
            hB[buff_memLR(i ,x,y,pitch)] = f[i ];
    }
    syncthreads();
    if(check[0] == 1){
    //reduction for force
    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumX[threadIdx.x] += sumX[threadIdx.x+halfPoint];
            sumY[threadIdx.x] += sumY[threadIdx.x+halfPoint];
            sumZ[threadIdx.x] += sumZ[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&FX[t-STARTF],sumX[0]);
        atomicAdd(&FY[t-STARTF],sumY[0]);
        atomicAdd(&FZ[t-STARTF],sumZ[0]);
    }
    }

}

__global__ void update_bot_LR(float* gB, float* gA, float* fA, float* temp,
                            float omega, size_t pitch, int GPU, int zInner, float* FX, float* FY, float* FZ, int t, int flag_F)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    //int z = (zInner+2)-1;
    int j = x+y*pitch;//index on padded mem (pitch in elements)
    float xcoord = LRX0+x*LRFACTOR;
	float ycoord = LRY0+y*LRFACTOR;
	//float zcoord = LRZ0+GPU*LRFACTOR*z;
	float zcoord = LRZ0+LRFACTOR*(GPU*(zInner+2)-1);
	int im = ImageFcnLR(xcoord,ycoord,zcoord);
    float f[19];
    __shared__ float sumX[BLOCKSIZELRX], sumY[BLOCKSIZELRX], sumZ[BLOCKSIZELRX];
    __shared__ int check[1];
    check[0] = 0;
    syncthreads();

    f[0 ]= gA  [j];
    f[1 ]= gA  [buff_memLR(1 ,x-1,y  ,pitch)];
    f[3 ]= gA  [buff_memLR(3 ,x+1,y  ,pitch)];
    f[2 ]= gA  [buff_memLR(2 ,x  ,y-1,pitch)];
    f[5 ]= gA  [buff_memLR(5 ,x-1,y-1,pitch)];
    f[6 ]= gA  [buff_memLR(6 ,x+1,y-1,pitch)];
    f[4 ]= gA  [buff_memLR(4 ,x  ,y+1,pitch)];
    f[7 ]= gA  [buff_memLR(7 ,x+1,y+1,pitch)];
    f[8 ]= gA  [buff_memLR(8 ,x-1,y+1,pitch)];
    f[9 ]= temp[buff_memLR(9 ,x  ,y  ,pitch)];
    f[10]= temp[buff_memLR(10,x-1,y  ,pitch)];
    f[11]= temp[buff_memLR(11,x  ,y-1,pitch)];
    f[12]= temp[buff_memLR(12,x+1,y  ,pitch)];
    f[13]= temp[buff_memLR(13,x  ,y+1,pitch)];
    f[14]= fA  [   f_memLR(14,x  ,y  ,0,pitch, zInner)];
    f[15]= fA  [   f_memLR(15,x-1,y  ,0,pitch, zInner)];
    f[16]= fA  [   f_memLR(16,x  ,y-1,0,pitch, zInner)];
    f[17]= fA  [   f_memLR(17,x+1,y  ,0,pitch, zInner)];
    f[18]= fA  [   f_memLR(18,x  ,y+1,0,pitch, zInner)];

    if(im == 1 || im ==10){//BB
        if(im == 10 && flag_F == 1){
        check[0] = 1;
        sumX[threadIdx.x]=2.f*f[ 1]-2.f*f[ 3]+2.f*f[ 5]+2.f*f[ 8]-2.f*f[ 6];
        sumX[threadIdx.x]+=-2.f*f[ 7]+2.f*f[10]-2.f*f[12]+2.f*f[15]-2.f*f[17];
        sumY[threadIdx.x]=2.f*f[ 2]-2.f*f[ 4]+2.f*f[ 5]-2.f*f[ 8]+2.f*f[ 6];
        sumY[threadIdx.x]+=-2.f*f[ 7]+2.f*f[11]-2.f*f[13]+2.f*f[16]-2.f*f[18];
        sumZ[threadIdx.x]=2.f*f[ 9]+2.f*f[10]+2.f*f[11]+2.f*f[12]+2.f*f[13];
        sumZ[threadIdx.x]+=-2.f*f[14]-2.f*f[15]-2.f*f[16]-2.f*f[17]-2.f*f[18];
        }
        else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        }
        gB[buff_memLR(0 ,x,y,pitch)] = f[0 ];
        gB[buff_memLR(1 ,x,y,pitch)] = f[3 ];
        gB[buff_memLR(2 ,x,y,pitch)] = f[4 ];
        gB[buff_memLR(3 ,x,y,pitch)] = f[1 ];
        gB[buff_memLR(4 ,x,y,pitch)] = f[2 ];
        gB[buff_memLR(5 ,x,y,pitch)] = f[7 ];
        gB[buff_memLR(6 ,x,y,pitch)] = f[8 ];
        gB[buff_memLR(7 ,x,y,pitch)] = f[5 ];
        gB[buff_memLR(8 ,x,y,pitch)] = f[6 ];
        gB[buff_memLR(9 ,x,y,pitch)] = f[14];
        gB[buff_memLR(10,x,y,pitch)] = f[17];
        gB[buff_memLR(11,x,y,pitch)] = f[18];
        gB[buff_memLR(12,x,y,pitch)] = f[15];
        gB[buff_memLR(13,x,y,pitch)] = f[16];
        gB[buff_memLR(14,x,y,pitch)] = f[9 ];
        gB[buff_memLR(15,x,y,pitch)] = f[12];
        gB[buff_memLR(16,x,y,pitch)] = f[13];
        gB[buff_memLR(17,x,y,pitch)] = f[10];
        gB[buff_memLR(18,x,y,pitch)] = f[11];
    }
    else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;

        mrt_collide(f,omega,LRFACTOR);

        for(int i = 0; i<19; i++)
            gB[buff_memLR(i ,x,y,pitch)] = f[i ];
    }
    syncthreads();
    if(check[0] == 1){
    //reduction for force
    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumX[threadIdx.x] += sumX[threadIdx.x+halfPoint];
            sumY[threadIdx.x] += sumY[threadIdx.x+halfPoint];
            sumZ[threadIdx.x] += sumZ[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&FX[t-STARTF],sumX[0]);
        atomicAdd(&FY[t-STARTF],sumY[0]);
        atomicAdd(&FZ[t-STARTF],sumZ[0]);
    }
    }
}

__global__ void update_inn_LR(float* fB, float* fA, float* g, float* h, float omega, size_t pitch, int GPU, int zInner, float* velAv_u, float* velAv_v, float* velFluc_u, float* velFluc_v, float* FX, float* FY, float* FZ, int t, int flag_F)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;//coord in linear mem
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
	int j = x+y*pitch+z*YLRDIM*pitch;//index on padded mem (pitch in elements)
	int im = ImageFcnLR(LRX0+LRFACTOR*x,LRY0+LRFACTOR*y,LRZ0+LRFACTOR*(GPU*(zInner+2)+1+z));
    float f[19];
    __shared__ float sumX[BLOCKSIZELRX], sumY[BLOCKSIZELRX], sumZ[BLOCKSIZELRX];
    __shared__ int check[1];
    check[0] = 0;
    syncthreads();

    f[ 0] = fA[j];
    f[ 1] = fA[f_memLR   (1 ,x-1,y  ,z  ,pitch, zInner)];
    f[ 3] = fA[f_memLR   (3 ,x+1,y  ,z  ,pitch, zInner)];
    f[ 2] = fA[f_memLR   (2 ,x  ,y-1,z  ,pitch, zInner)];
    f[ 5] = fA[f_memLR   (5 ,x-1,y-1,z  ,pitch, zInner)];
    f[ 6] = fA[f_memLR   (6 ,x+1,y-1,z  ,pitch, zInner)];
    f[ 4] = fA[f_memLR   (4 ,x  ,y+1,z  ,pitch, zInner)];
    f[ 7] = fA[f_memLR   (7 ,x+1,y+1,z  ,pitch, zInner)];
    f[ 8] = fA[f_memLR   (8 ,x-1,y+1,z  ,pitch, zInner)];

    if(z==zInner-1){//top nodes need info from h
    f[ 9] =fA[   f_memLR(9 ,x  ,y  ,z-1,pitch, zInner)];
    f[10]= fA[   f_memLR(10,x-1,y  ,z-1,pitch, zInner)];
    f[11]= fA[   f_memLR(11,x  ,y-1,z-1,pitch, zInner)];
    f[12]= fA[   f_memLR(12,x+1,y  ,z-1,pitch, zInner)];
    f[13]= fA[   f_memLR(13,x  ,y+1,z-1,pitch, zInner)];
    f[14]= h [buff_memLR(14,x  ,y  ,pitch)];
    f[15]= h [buff_memLR(15,x-1,y  ,pitch)];
    f[16]= h [buff_memLR(16,x  ,y-1,pitch)];
    f[17]= h [buff_memLR(17,x+1,y  ,pitch)];
    f[18]= h [buff_memLR(18,x  ,y+1,pitch)];
    }
    else if(z==0){//bottom nodes need info from g
    f[ 9] =g [buff_memLR(9 ,x  ,y  ,pitch)];
    f[10]= g [buff_memLR(10,x-1,y  ,pitch)];
    f[11]= g [buff_memLR(11,x  ,y-1,pitch)];
    f[12]= g [buff_memLR(12,x+1,y  ,pitch)];
    f[13]= g [buff_memLR(13,x  ,y+1,pitch)];
    f[14]= fA[   f_memLR(14,x  ,y  ,z+1,pitch, zInner)];
    f[15]= fA[   f_memLR(15,x-1,y  ,z+1,pitch, zInner)];
    f[16]= fA[   f_memLR(16,x  ,y-1,z+1,pitch, zInner)];
    f[17]= fA[   f_memLR(17,x+1,y  ,z+1,pitch, zInner)];
    f[18]= fA[   f_memLR(18,x  ,y+1,z+1,pitch, zInner)];
    }
    else{//normal nodes
    f[ 9] =fA[f_memLR(9 ,x  ,y  ,z-1,pitch,zInner)];
    f[10]= fA[f_memLR(10,x-1,y  ,z-1,pitch,zInner)];
    f[11]= fA[f_memLR(11,x  ,y-1,z-1,pitch,zInner)];
    f[12]= fA[f_memLR(12,x+1,y  ,z-1,pitch,zInner)];
    f[13]= fA[f_memLR(13,x  ,y+1,z-1,pitch,zInner)];
    f[14]= fA[f_memLR(14,x  ,y  ,z+1,pitch,zInner)];
    f[15]= fA[f_memLR(15,x-1,y  ,z+1,pitch,zInner)];
    f[16]= fA[f_memLR(16,x  ,y-1,z+1,pitch,zInner)];
    f[17]= fA[f_memLR(17,x+1,y  ,z+1,pitch,zInner)];
    f[18]= fA[f_memLR(18,x  ,y+1,z+1,pitch,zInner)];

    }//end normal nodes

    if(im == 1 || im ==10){//BB
        if(im == 10 && flag_F == 1){
        check[0] = 1;
        sumX[threadIdx.x]=2.f*f[ 1]-2.f*f[ 3]+2.f*f[ 5]+2.f*f[ 8]-2.f*f[ 6];
        sumX[threadIdx.x]+=-2.f*f[ 7]+2.f*f[10]-2.f*f[12]+2.f*f[15]-2.f*f[17];
        sumY[threadIdx.x]=2.f*f[ 2]-2.f*f[ 4]+2.f*f[ 5]-2.f*f[ 8]+2.f*f[ 6];
        sumY[threadIdx.x]+=-2.f*f[ 7]+2.f*f[11]-2.f*f[13]+2.f*f[16]-2.f*f[18];
        sumZ[threadIdx.x]=2.f*f[ 9]+2.f*f[10]+2.f*f[11]+2.f*f[12]+2.f*f[13];
        sumZ[threadIdx.x]+=-2.f*f[14]-2.f*f[15]-2.f*f[16]-2.f*f[17]-2.f*f[18];
        }
        else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;
        }
        fB[f_memLR(1 ,x,y,z,pitch,zInner)] = f[ 3] ;
        fB[f_memLR(2 ,x,y,z,pitch,zInner)] = f[ 4] ;
        fB[f_memLR(3 ,x,y,z,pitch,zInner)] = f[ 1] ;
        fB[f_memLR(4 ,x,y,z,pitch,zInner)] = f[ 2] ;
        fB[f_memLR(5 ,x,y,z,pitch,zInner)] = f[ 7] ;
        fB[f_memLR(6 ,x,y,z,pitch,zInner)] = f[ 8] ;
        fB[f_memLR(7 ,x,y,z,pitch,zInner)] = f[ 5] ;
        fB[f_memLR(8 ,x,y,z,pitch,zInner)] = f[ 6] ;
        fB[f_memLR(9 ,x,y,z,pitch,zInner)] = f[14];
        fB[f_memLR(10,x,y,z,pitch,zInner)] = f[17];
        fB[f_memLR(11,x,y,z,pitch,zInner)] = f[18];
        fB[f_memLR(12,x,y,z,pitch,zInner)] = f[15];
        fB[f_memLR(13,x,y,z,pitch,zInner)] = f[16];
        fB[f_memLR(14,x,y,z,pitch,zInner)] = f[ 9] ;
        fB[f_memLR(15,x,y,z,pitch,zInner)] = f[12];
        fB[f_memLR(16,x,y,z,pitch,zInner)] = f[13];
        fB[f_memLR(17,x,y,z,pitch,zInner)] = f[10];
        fB[f_memLR(18,x,y,z,pitch,zInner)] = f[11];
    }
    else{
        sumX[threadIdx.x]=0.f;
        sumY[threadIdx.x]=0.f;
        sumZ[threadIdx.x]=0.f;

        mrt_collide(f,omega,LRFACTOR);

        if(VELAV == 1){
            if(t>=START_VELAV && t<START_VELFLUC){
                float u_Av = velAv_u[x+y*pitch+(z+1)*pitch*YLRDIM];
                float v_Av = velAv_v[x+y*pitch+(z+1)*pitch*YLRDIM];
                vel_avLR(f,u_Av,v_Av,t);
                velAv_u[x+y*pitch+(z+1)*pitch*YLRDIM] = u_Av;
                velAv_v[x+y*pitch+(z+1)*pitch*YLRDIM] = v_Av;
            }
            else if(t>=START_VELFLUC){
                float u_Av = velAv_u[x+y*pitch+(z+1)*pitch*YLRDIM];
                float v_Av = velAv_v[x+y*pitch+(z+1)*pitch*YLRDIM];
                float u_fluc = velFluc_u[x+y*pitch+(z+1)*pitch*YLRDIM];
                float v_fluc = velFluc_v[x+y*pitch+(z+1)*pitch*YLRDIM];
                vel_flucLR(f,u_Av,v_Av,u_fluc,v_fluc,t);
                velFluc_u[x+y*pitch+(z+1)*pitch*YLRDIM] = u_fluc;
                velFluc_v[x+y*pitch+(z+1)*pitch*YLRDIM] = v_fluc;
            }
        }

        for(int i = 0; i<19; i++)
            fB[f_memLR(i ,x,y,z,pitch,zInner)] = f[ i] ;
    }

    syncthreads();
    if(check[0] == 1){
    //reduction for force
    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumX[threadIdx.x] += sumX[threadIdx.x+halfPoint];
            sumY[threadIdx.x] += sumY[threadIdx.x+halfPoint];
            sumZ[threadIdx.x] += sumZ[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&FX[t-STARTF],sumX[0]);
        atomicAdd(&FY[t-STARTF],sumY[0]);
        atomicAdd(&FZ[t-STARTF],sumZ[0]);
    }
    }

}

/*
InterpCF is used on the LR grid. It first uses part of its threads to read from the coarse mesh nodes that completely envelope the fine mesh nodes, and loads the f's into shared memory. Next, all threads use the shared memory data to interpolate and scale the f's
*/
__global__ void InterpCF(float* f_f, float* g_f, float* h_f, size_t pitch_f, float* m_f_c, float* m_g_c, float* m_h_c, float* m_g_temp, size_t pitch_m, float SF, float omega_c, int GPU, int zInner, int zInner_f)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
    __shared__ float mom_c[BLOCKSIZEINTERP][2][2][9];
    __shared__ float S_c[BLOCKSIZEINTERP][2][2][6];
    //int GPU = 0;
	int im = ImageFcnLR(LRX0+LRFACTOR*x,LRY0+LRFACTOR*y,LRZ0+LRFACTOR*(GPU*(zInner_f+2)+z));

    if(blockIdx.z == 0 && threadIdx.x<ceil(BLOCKSIZEINTERP*LRFACTOR)+1 && threadIdx.z<2 && threadIdx.y<2)
    {
        //use g and g_temp
        int x_c = threadIdx.x+blockIdx.x*BLOCKSIZEINTERP*LRFACTOR;//in coarse grid, blockdim.x is LRX*LRFACTOR
        int y_c = threadIdx.y+blockIdx.y;//in coarse grid, blockdim.y is 1
        int ymax = YLRDIM*LRFACTOR+1;
        if(threadIdx.z == 0){
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_g_temp[x_c+y_c*pitch_m+i*ymax*pitch_m];
        }
        else{
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_g_c[x_c+y_c*pitch_m+i*ymax*pitch_m];
        }
//        float S[6];//float m_strain[9];
//        for(int i = 0; i<9; i++)
//            m_strain[i] = mom_c[i][threadIdx.x][threadIdx.y][threadIdx.z];
//        for(int i = 0; i<6; i++)
//        S_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= S[i];
        StrainRate(S_c[threadIdx.x][threadIdx.y][threadIdx.z],mom_c[threadIdx.x][threadIdx.y][threadIdx.z],1.f);
    }
    else if(blockIdx.z == 1 && threadIdx.x<ceil(BLOCKSIZEINTERP*LRFACTOR)+1 && threadIdx.z<2 && threadIdx.y<2)
    {
        //use g and f   
        int x_c = threadIdx.x+blockIdx.x*BLOCKSIZEINTERP*LRFACTOR;//in coarse grid, blockdim.x is LRX*LRFACTOR
        int y_c = threadIdx.y+blockIdx.y;//in coarse grid, blockdim.y is 1
        int ymax = YLRDIM*LRFACTOR+1;
        if(threadIdx.z == 0){
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_g_c[x_c+y_c*pitch_m+i*ymax*pitch_m];
        }
        else{
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_f_c[x_c+y_c*pitch_m+i*ymax*pitch_m*zInner];
        }
//        float S[6];//float m_strain[9];
//        for(int i = 0; i<9; i++)
//            m_strain[i] = mom_c[i][threadIdx.x][threadIdx.y][threadIdx.z];
//        for(int i = 0; i<6; i++)
//        S_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= S[i];
        StrainRate(S_c[threadIdx.x][threadIdx.y][threadIdx.z],mom_c[threadIdx.x][threadIdx.y][threadIdx.z],1.f);
    }
    else if(blockIdx.z == zInner+1 && threadIdx.x<ceil(BLOCKSIZEINTERP*LRFACTOR)+1 && threadIdx.z<2 && threadIdx.y<2)
    {
        //use h and f   
        int x_c = threadIdx.x+blockIdx.x*BLOCKSIZEINTERP*LRFACTOR;//in coarse grid, blockdim.x is LRX*LRFACTOR
        int y_c = threadIdx.y+blockIdx.y;//in coarse grid, blockdim.y is 1
        int ymax = YLRDIM*LRFACTOR+1;
        if(threadIdx.z == 0){
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_f_c[x_c+y_c*pitch_m+(zInner-1)*ymax*pitch_m+i*ymax*pitch_m*zInner];
        }
        else{
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_h_c[x_c+y_c*pitch_m+i*ymax*pitch_m];
        }
//        float S[6];//float m_strain[9];
//        for(int i = 0; i<9; i++)
//            m_strain[i] = mom_c[i][threadIdx.x][threadIdx.y][threadIdx.z];
//        for(int i = 0; i<6; i++)
//        S_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= S[i];        
        StrainRate(S_c[threadIdx.x][threadIdx.y][threadIdx.z],mom_c[threadIdx.x][threadIdx.y][threadIdx.z],1.f);
    }
    else if(threadIdx.x<ceil(BLOCKSIZEINTERP*LRFACTOR)+1 && threadIdx.z<2 && threadIdx.y<2){//use f only
        int x_c = threadIdx.x+blockIdx.x*BLOCKSIZEINTERP*LRFACTOR;//in coarse grid, blockdim.x is LRX*LRFACTOR
        int y_c = threadIdx.y+blockIdx.y;//in coarse grid, blockdim.y is 1
        int z_c = threadIdx.z+blockIdx.z-2;//in coarse grid, blockdim.z is 1; -2 to account for g and lower halo
        int ymax = YLRDIM*LRFACTOR+1;
        for(int i = 0; i<9; i++)
            mom_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= m_f_c[x_c+y_c*pitch_m+z_c*ymax*pitch_m+i*ymax*pitch_m*zInner];
//        float S[6];//float m_strain[9];
//        for(int i = 0; i<9; i++)
//            m_strain[i] = mom_c[i][threadIdx.x][threadIdx.y][threadIdx.z];
//        for(int i = 0; i<6; i++)
//        S_c[threadIdx.x][threadIdx.y][threadIdx.z][i]= S[i];
        StrainRate(S_c[threadIdx.x][threadIdx.y][threadIdx.z],mom_c[threadIdx.x][threadIdx.y][threadIdx.z],1.f);
    }
    syncthreads();
    if(x<LRLEVEL || x>XLRDIM-LRLEVEL-1 || y<LRLEVEL || y>YLRDIM-LRLEVEL-1){
    //if(x<LRLEVEL+3 || x>XLRDIM-LRLEVEL-5 || y<LRLEVEL+3 || y>YLRDIM-LRLEVEL-5){
    //interpolate from shared mem
    int xm = int(threadIdx.x*LRFACTOR+LRFACTOR*0.5f);
    int ym = int(threadIdx.y*LRFACTOR+LRFACTOR*0.5f);
    int zm = int(threadIdx.z*LRFACTOR+LRFACTOR*0.5f);
    int xp = xm+1; //int yp = ym+1; int zp = zm+1;
    float xf = (threadIdx.x*LRFACTOR+LRFACTOR*0.5f)-xm;
    float yf = (threadIdx.y*LRFACTOR+LRFACTOR*0.5f)-ym;
    float zf = (threadIdx.z*LRFACTOR+LRFACTOR*0.5f)-zm;
    float mom[9];
    for(int i = 0; i<9; i++){
        float v000 = mom_c[xm][0][0][i];
        float v001 = mom_c[xp][0][0][i];
        float v010 = mom_c[xm][1][0][i];
        float v011 = mom_c[xp][1][0][i];
        float v100 = mom_c[xm][0][1][i];
        float v101 = mom_c[xp][0][1][i];
        float v110 = mom_c[xm][1][1][i];
        float v111 = mom_c[xp][1][1][i];
        mom[i] = trilinear_interp(v000, v001, v010, v011, v100, v101, v110, v111, xf, yf, zf);
    }
    if(ORDER == 2)
    {
    float u_x1,u_x2,u_x3,u_x4,u_x5,u_x6,u_x7,u_x8;
    float v_y1,v_y2,v_y3,v_y4,v_y5,v_y6,v_y7,v_y8;
    float w_z1,w_z2,w_z3,w_z4,w_z5,w_z6,w_z7,w_z8;
    float Sxy1,Sxy2,Sxy3,Sxy4,Sxy5,Sxy6,Sxy7,Sxy8;
    float Syz1,Syz2,Syz3,Syz4,Syz5,Syz6,Syz7,Syz8;
    float Sxz1,Sxz2,Sxz3,Sxz4,Sxz5,Sxz6,Sxz7,Sxz8;
    u_x1=S_c[xm][0][0][0];v_y1=S_c[xm][0][0][1];w_z1=S_c[xm][0][0][2];Sxy1=S_c[xm][0][0][3];Syz1=S_c[xm][0][0][4];Sxz1=S_c[xm][0][0][5];
    u_x2=S_c[xp][0][0][0];v_y2=S_c[xp][0][0][1];w_z2=S_c[xp][0][0][2];Sxy2=S_c[xp][0][0][3];Syz2=S_c[xp][0][0][4];Sxz2=S_c[xp][0][0][5];
    u_x3=S_c[xm][1][0][0];v_y3=S_c[xm][1][0][1];w_z3=S_c[xm][1][0][2];Sxy3=S_c[xm][1][0][3];Syz3=S_c[xm][1][0][4];Sxz3=S_c[xm][1][0][5];
    u_x4=S_c[xp][1][0][0];v_y4=S_c[xp][1][0][1];w_z4=S_c[xp][1][0][2];Sxy4=S_c[xp][1][0][3];Syz4=S_c[xp][1][0][4];Sxz4=S_c[xp][1][0][5];
    u_x5=S_c[xm][0][1][0];v_y5=S_c[xm][0][1][1];w_z5=S_c[xm][0][1][2];Sxy5=S_c[xm][0][1][3];Syz5=S_c[xm][0][1][4];Sxz5=S_c[xm][0][1][5];
    u_x6=S_c[xp][0][1][0];v_y6=S_c[xp][0][1][1];w_z6=S_c[xp][0][1][2];Sxy6=S_c[xp][0][1][3];Syz6=S_c[xp][0][1][4];Sxz6=S_c[xp][0][1][5];
    u_x7=S_c[xm][1][1][0];v_y7=S_c[xm][1][1][1];w_z7=S_c[xm][1][1][2];Sxy7=S_c[xm][1][1][3];Syz7=S_c[xm][1][1][4];Sxz7=S_c[xm][1][1][5];
    u_x8=S_c[xp][1][1][0];v_y8=S_c[xp][1][1][1];w_z8=S_c[xp][1][1][2];Sxy8=S_c[xp][1][1][3];Syz8=S_c[xp][1][1][4];Sxz8=S_c[xp][1][1][5];

    float m03,m05,m07, m13,m15,m17, m23,m25,m27, m33,m35,m37, m43,m45,m47, m53,m55,m57, m63,m65,m67, m73,m75,m77;
    m03=mom_c[xm][0][0][1];m05=mom_c[xm][0][0][2];m07=mom_c[xm][0][0][3];
    m13=mom_c[xp][0][0][1];m15=mom_c[xp][0][0][2];m17=mom_c[xp][0][0][3];
    m23=mom_c[xm][1][0][1];m25=mom_c[xm][1][0][2];m27=mom_c[xm][1][0][3];
    m33=mom_c[xp][1][0][1];m35=mom_c[xp][1][0][2];m37=mom_c[xp][1][0][3];
    m43=mom_c[xm][0][1][1];m45=mom_c[xm][0][1][2];m47=mom_c[xm][0][1][3];
    m53=mom_c[xp][0][1][1];m55=mom_c[xp][0][1][2];m57=mom_c[xp][0][1][3];
    m63=mom_c[xm][1][1][1];m65=mom_c[xm][1][1][2];m67=mom_c[xm][1][1][3];
    m73=mom_c[xp][1][1][1];m75=mom_c[xp][1][1][2];m77=mom_c[xp][1][1][3];

    float cx = -((u_x8-u_x7+u_x6-u_x5+u_x4-u_x3+u_x2-u_x1))*0.03125f;
    float cy = -((Sxy8+Sxy7-Sxy6-Sxy5+Sxy4+Sxy3-Sxy2-Sxy1)-m75+m65+m55-m45-m35+m25+m15-m05)*0.0625f;
    float cz = -((Sxz8+Sxz7+Sxz6+Sxz5-Sxz4-Sxz3-Sxz2-Sxz1)-m77+m67-m57+m47+m37-m27+m17-m07)*0.0625f;
    float dx = -((Sxy8-Sxy7+Sxy6-Sxy5+Sxy4-Sxy3+Sxy2-Sxy1)-m73+m63+m53-m43-m33+m23+m13-m03)*0.0625f;
    float dy = -((v_y8+v_y7-v_y6-v_y5+v_y4+v_y3-v_y2-v_y1))*0.03125f;
    float dz = -((Syz8+Syz7+Syz6+Syz5-Syz4-Syz3-Syz2-Syz1)-m77-m67+m57+m47+m37+m27-m17-m07)*0.0625f;
    float ex = -((Sxz8-Sxz7+Sxz6-Sxz5+Sxz4-Sxz3+Sxz2-Sxz1)-m73+m63-m53+m43+m33-m23+m13-m03)*0.0625f;
    float ey = -((Syz8+Syz7-Syz6-Syz5+Syz4+Syz3-Syz2-Syz1)-m75-m65+m55+m45+m35+m25-m15-m05)*0.0625f;
    float ez = -((w_z8+w_z7+w_z6+w_z5-w_z4-w_z3-w_z2-w_z1))*0.03125f;
    
    float xpr = 4.f*xf*xf-4.f*xf+1.f;
    float ypr = 4.f*yf*yf-4.f*yf+1.f;
    float zpr = 4.f*zf*zf-4.f*zf+1.f;
    mom[1] += cx*(1.f-xpr)+cy*(1.f-ypr)+cz*(1.f-zpr);
    mom[2] += dx*(1.f-xpr)+dy*(1.f-ypr)+dz*(1.f-zpr);
    mom[3] += ex*(1.f-xpr)+ey*(1.f-ypr)+ez*(1.f-zpr);
    }

    float f[19];
    //InvertPhysicalMoments(f,mom,SF);
    InvertPhysicalMoments_LES_cf(f,mom,SF,omega_c);

    if(im != 1 && im != 10){

    if(z==0){
    for(int i = 0; i<19; i++){
        g_f[buff_memLR(i,x,y,pitch_f)]=f[i];
    }
    }
    else if(z==gridDim.z*blockDim.z-1){
    for(int i = 0; i<19; i++){
        h_f[buff_memLR(i,x,y,pitch_f)]=f[i];
    }
    }
    else{
    for(int i = 0; i<19; i++){
        f_f[f_memLR(i,x,y,z-1,pitch_f,zInner_f)]=f[i];
    }   
    }
    }
    }

}

__global__ void InterpFC(float* f_c, float* g_c, float* h_c, float* f_f, float* h_f, float* temp_f, size_t pitch_c, size_t pitch_f, float SF, float omega_f, int GPU, int zInner, int zInner_f)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;
    int y = threadIdx.y+blockIdx.y*blockDim.y;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
    //if( (x > LRX0+1 && x < LRX0+XLRDIM*LRFACTOR-1 && y > LRY0+1 && y < LRY0+YLRDIM*LRFACTOR-1) &&
    //(x == int(LRX0+2) || x == int(LRX0+XLRDIM*LRFACTOR-2) || y == int(LRY0+2) || y == int(LRY0+YLRDIM*LRFACTOR-2)))
    //(true))
    //if( (x > LRX0+5 && x < LRX0+XLRDIM*LRFACTOR-6 && y > LRY0+5 && y < LRY0+YLRDIM*LRFACTOR-6) &&
    if( (x > LRX0+1 && x < LRX0+XLRDIM*LRFACTOR-2 && y > LRY0+1 && y < LRY0+YLRDIM*LRFACTOR-2) &&
    //(x == int(LRX0+2) || x == int(LRX0+XLRDIM*LRFACTOR-2) || y == int(LRY0+2) || y == int(LRY0+YLRDIM*LRFACTOR-2)))
    (true))
    {
        float f[19];
        float mom[8][9];//physical moments of 8 neighboring nodes
        float S_f[8][6];//strain rate tensor of 8 neighboring nodes
        int xm = LRLEVEL*(x-LRX0);
        int ym = LRLEVEL*(y-LRY0);
        int zm = LRLEVEL*(z-(-(1.f-0.5f*LRFACTOR)))-1;//LRZ0=-(1.f-0.5f*LRFACTOR), and -1 to account for g_LR
        int xp = xm+1;
        int yp = ym+1;
        int zp = zm+1;
        //top nodes. interp between h and h_temp. output to h
        if(z == zInner+1)
        {
            for(int i = 0; i<19; i++)
                            f[i] = temp_f[buff_memLR(i,xm,ym,pitch_f)];
            PhysicalMoments(mom[0],f);
            StrainRate(S_f[0],mom[0],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = temp_f[buff_memLR(i,xp,ym,pitch_f)];
            PhysicalMoments(mom[1],f);
            StrainRate(S_f[1],mom[1],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = temp_f[buff_memLR(i,xm,yp,pitch_f)];
            PhysicalMoments(mom[2],f);
            StrainRate(S_f[2],mom[2],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = temp_f[buff_memLR(i,xp,yp,pitch_f)];
            PhysicalMoments(mom[3],f);
            StrainRate(S_f[3],mom[3],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = h_f[buff_memLR(i,xm,ym,pitch_f)];
            PhysicalMoments(mom[4],f);
            StrainRate(S_f[4],mom[4],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = h_f[buff_memLR(i,xp,ym,pitch_f)];
            PhysicalMoments(mom[5],f);
            StrainRate(S_f[5],mom[5],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = h_f[buff_memLR(i,xm,yp,pitch_f)];
            PhysicalMoments(mom[6],f);
            StrainRate(S_f[6],mom[6],1.f);
            for(int i = 0; i<19; i++)
                            f[i] = h_f[buff_memLR(i,xp,yp,pitch_f)];
            PhysicalMoments(mom[7],f);
            StrainRate(S_f[7],mom[7],1.f);
        }

        //inner nodes. output to g or f
        else{
            for(int i = 0; i<19; i++)
                            f[i] = f_f[f_memLR(i,xm,ym,zm,pitch_f,zInner_f)];
            PhysicalMoments(mom[0],f); 
            StrainRate(S_f[0],mom[0],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xp,ym,zm,pitch_f,zInner_f)];
            PhysicalMoments(mom[1],f); 
            StrainRate(S_f[1],mom[1],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xm,yp,zm,pitch_f,zInner_f)];
            PhysicalMoments(mom[2],f); 
            StrainRate(S_f[2],mom[2],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xp,yp,zm,pitch_f,zInner_f)];
            PhysicalMoments(mom[3],f); 
            StrainRate(S_f[3],mom[3],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xm,ym,zp,pitch_f,zInner_f)];
            PhysicalMoments(mom[4],f); 
            StrainRate(S_f[4],mom[4],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xp,ym,zp,pitch_f,zInner_f)];
            PhysicalMoments(mom[5],f); 
            StrainRate(S_f[5],mom[5],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xm,yp,zp,pitch_f,zInner_f)];
            PhysicalMoments(mom[6],f); 
            StrainRate(S_f[6],mom[6],1.f);         
            for(int i = 0; i<19; i++)  
                            f[i] = f_f[f_memLR(i,xp,yp,zp,pitch_f,zInner_f)];
            PhysicalMoments(mom[7],f);
            StrainRate(S_f[7],mom[7],1.f);
        }
        if(ORDER == 1){
        for(int i = 0; i<9; i++)
        mom[0][i] = 0.125f*(mom[0][i]+mom[1][i]+mom[2][i]+mom[3][i]+mom[4][i]+mom[5][i]+mom[6][i]+mom[7][i]);
        }
        else if(ORDER == 2)
        {
            float u_x1,u_x2,u_x3,u_x4,u_x5,u_x6,u_x7,u_x8;
            float v_y1,v_y2,v_y3,v_y4,v_y5,v_y6,v_y7,v_y8;
            float w_z1,w_z2,w_z3,w_z4,w_z5,w_z6,w_z7,w_z8;
            float Sxy1,Sxy2,Sxy3,Sxy4,Sxy5,Sxy6,Sxy7,Sxy8;
            float Syz1,Syz2,Syz3,Syz4,Syz5,Syz6,Syz7,Syz8;
            float Sxz1,Sxz2,Sxz3,Sxz4,Sxz5,Sxz6,Sxz7,Sxz8;
            u_x1=S_f[0][0];v_y1=S_f[0][1];w_z1=S_f[0][2];Sxy1=S_f[0][3];Syz1=S_f[0][4];Sxz1=S_f[0][5];
            u_x2=S_f[1][0];v_y2=S_f[1][1];w_z2=S_f[1][2];Sxy2=S_f[1][3];Syz2=S_f[1][4];Sxz2=S_f[1][5];
            u_x3=S_f[2][0];v_y3=S_f[2][1];w_z3=S_f[2][2];Sxy3=S_f[2][3];Syz3=S_f[2][4];Sxz3=S_f[2][5];
            u_x4=S_f[3][0];v_y4=S_f[3][1];w_z4=S_f[3][2];Sxy4=S_f[3][3];Syz4=S_f[3][4];Sxz4=S_f[3][5];
            u_x5=S_f[4][0];v_y5=S_f[4][1];w_z5=S_f[4][2];Sxy5=S_f[4][3];Syz5=S_f[4][4];Sxz5=S_f[4][5];
            u_x6=S_f[5][0];v_y6=S_f[5][1];w_z6=S_f[5][2];Sxy6=S_f[5][3];Syz6=S_f[5][4];Sxz6=S_f[5][5];
            u_x7=S_f[6][0];v_y7=S_f[6][1];w_z7=S_f[6][2];Sxy7=S_f[6][3];Syz7=S_f[6][4];Sxz7=S_f[6][5];
            u_x8=S_f[7][0];v_y8=S_f[7][1];w_z8=S_f[7][2];Sxy8=S_f[7][3];Syz8=S_f[7][4];Sxz8=S_f[7][5];
        
            float m03,m05,m07, m13,m15,m17, m23,m25,m27, m33,m35,m37, m43,m45,m47, m53,m55,m57, m63,m65,m67, m73,m75,m77;
            m03=mom[0][1];m05=mom[0][2];m07=mom[0][3];
            m13=mom[1][1];m15=mom[1][2];m17=mom[1][3];
            m23=mom[2][1];m25=mom[2][2];m27=mom[2][3];
            m33=mom[3][1];m35=mom[3][2];m37=mom[3][3];
            m43=mom[4][1];m45=mom[4][2];m47=mom[4][3];
            m53=mom[5][1];m55=mom[5][2];m57=mom[5][3];
            m63=mom[6][1];m65=mom[6][2];m67=mom[6][3];
            m73=mom[7][1];m75=mom[7][2];m77=mom[7][3];
        
            float cx = -((u_x8-u_x7+u_x6-u_x5+u_x4-u_x3+u_x2-u_x1))*0.03125f;
            float cy = -((Sxy8+Sxy7-Sxy6-Sxy5+Sxy4+Sxy3-Sxy2-Sxy1)-m75+m65+m55-m45-m35+m25+m15-m05)*0.0625f;
            float cz = -((Sxz8+Sxz7+Sxz6+Sxz5-Sxz4-Sxz3-Sxz2-Sxz1)-m77+m67-m57+m47+m37-m27+m17-m07)*0.0625f;
            float dx = -((Sxy8-Sxy7+Sxy6-Sxy5+Sxy4-Sxy3+Sxy2-Sxy1)-m73+m63+m53-m43-m33+m23+m13-m03)*0.0625f;
            float dy = -((v_y8+v_y7-v_y6-v_y5+v_y4+v_y3-v_y2-v_y1))*0.03125f;
            float dz = -((Syz8+Syz7+Syz6+Syz5-Syz4-Syz3-Syz2-Syz1)-m77-m67+m57+m47+m37+m27-m17-m07)*0.0625f;
            float ex = -((Sxz8-Sxz7+Sxz6-Sxz5+Sxz4-Sxz3+Sxz2-Sxz1)-m73+m63-m53+m43+m33-m23+m13-m03)*0.0625f;
            float ey = -((Syz8+Syz7-Syz6-Syz5+Syz4+Syz3-Syz2-Syz1)-m75-m65+m55+m45+m35+m25-m15-m05)*0.0625f;
            float ez = -((w_z8+w_z7+w_z6+w_z5-w_z4-w_z3-w_z2-w_z1))*0.03125f;

            for(int i = 0; i<9; i++)
                mom[0][i] = 0.125f*(mom[0][i]+mom[1][i]+mom[2][i]+mom[3][i]+mom[4][i]+mom[5][i]+mom[6][i]+mom[7][i]);
            
            float xpr = 0.f;//4.f*xf*xf-4.f*xf+1.f;
            float ypr = 0.f;//4.f*yf*yf-4.f*yf+1.f;
            float zpr = 0.f;//4.f*zf*zf-4.f*zf+1.f;
            mom[0][1] += cx*(1.f-xpr)+cy*(1.f-ypr)+cz*(1.f-zpr);
            mom[0][2] += dx*(1.f-xpr)+dy*(1.f-ypr)+dz*(1.f-zpr);
            mom[0][3] += ex*(1.f-xpr)+ey*(1.f-ypr)+ez*(1.f-zpr);
        }
        
        //InvertPhysicalMoments(f,mom[0],SF);
        InvertPhysicalMoments_LES_fc(f,mom[0],SF,omega_f);

        //for(int i = 0; i<19; i++) f[i] = 0.1f;

        //int GPU = 0;
        int im = ImageFcn(x,y,GPU*(zInner+2)+z,0);
        if(im != 1 && im != 10){
        

        if(z == 0){
            for(int i = 0; i<19; i++)
                g_c[buff_mem(i,x,y,pitch_c)]=f[i];
        }
        else if(z == zInner+1){
            for(int i = 0; i<19; i++)
                h_c[buff_mem(i,x,y,pitch_c)]=f[i];
        }
        else{
            for(int i = 0; i<19; i++)
                f_c[f_mem(i,x,y,z-1,pitch_c,zInner)]=f[i];
        }

        }


    }//end extraction region


}


__global__ void AverageV(float* fA, float* gA, float* hA, size_t pitch, int GPU, int zInner, float* Av_V, int t)
{
    int x = threadIdx.x+blockIdx.x*blockDim.x;
    int z = threadIdx.z+blockIdx.z*blockDim.z;
    float f[19];
    float v_av = 0;
    __shared__ float sumV[BLOCKSIZEX];
    syncthreads();
    if(z == 0){
    for(int i = 0; i<19; i++)
        f[i] = gA[buff_mem(i,x,DYNY,pitch)];
    }
    else if(z == zInner+1){
    for(int i = 0; i<19; i++)
        f[i] = hA[buff_mem(i,x,DYNY,pitch)];
    }
    else{
    for(int i = 0; i<19; i++)
        f[i] = fA[f_mem(i,x,DYNY,z-1,pitch,zInner)];
    }
    sumV[threadIdx.x] = f[2]-f[4]+f[5]+f[6]-f[7]-f[8]+f[11]-f[13]+f[16]-f[18];
    syncthreads();

    int nTotalThreads = blockDim.x;
    while(nTotalThreads > 1){
        int halfPoint = (nTotalThreads >> 1);
        if(threadIdx.x < halfPoint){
            sumV[threadIdx.x] += sumV[threadIdx.x+halfPoint];
        }
        syncthreads();
        nTotalThreads = halfPoint;
    }
    if(threadIdx.x == 0){
        atomicAdd(&Av_V[t],sumV[0]);
    }


}


void WriteResults(ostream &output, ostream &outputslice, float *fin, float *gin, float *hin, float **velAv,  
                  float **velFluc, float omega, int GPU_N, int GPU)
{
    float f[19];
    output<<"VARIABLES = \"X\",\"Y\",\"Z\",\"u\",\"v\",\"w\",\"rho\",\"velAv[0]\",\"velAv[1]\",\"ufluc\",\"vfluc\",\"Smag\"\n";
    output<<"ZONE F=POINT, I="<<XDIM<<", J="<<YDIM<<", K="<<ZDIM/GPU_N<<"\n";
    if(GPU == 0){
    outputslice<<"VARIABLES = \"X\",\"Y\",\"Z\",\"u\",\"v\",\"w\",\"rho\",\"velAv[0]\",\"velAv[1]\",\"ufluc\",\"vfluc\",\"Smag\"\n";
    outputslice<<"ZONE F=POINT, I="<<XDIM<<", J="<<YDIM<<", K="<<1<<"\n";
    }

    for(int j = 0; j<YDIM; j++){
    for(int i = 0; i<XDIM; i++){
        float rho = 0;
        for(int l = 0; l<19; l++){
            f[l] = gin[(i+j*XDIM)+l *XDIM*YDIM];
            rho += f[l];
        }
        float u = f[1]-f[3 ]+f[5 ]-f[6 ]-f[7 ]+f[8 ]+f[10]-f[12]+f[15]-f[17];
        float v = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
        float w = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
        output<<i<<", "<<j<<", "<<(ZDIM/GPU_N*GPU)<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv[0][i+j*XDIM]<<","<<velAv[1][i+j*XDIM]<<", "<<velFluc[0][i+j*XDIM]<<","<<velFluc[1][i+j*XDIM]<<","<<0<<endl;
    }}

    for(int k = 1; k<ZDIM/GPU_N-1; k++){
    for(int j = 0; j<YDIM; j++){
    for(int i = 0; i<XDIM; i++){
        float rho = 0;
        for(int l = 0; l<19; l++){
            f[l] = fin[(i+j*XDIM)+(k-1)*XDIM*YDIM+l*XDIM*YDIM*(ZDIM/GPU_N-2)];
            rho += f[l];
        }
        float u = f[1]-f[3 ]+f[5 ]-f[6 ]-f[7 ]+f[8 ]+f[10]-f[12]+f[15]-f[17];
        float v = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
        float w = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
        float m1 =-30.f*f[0]+-11.f*f[1]+-11.f*f[2]+-11.f*f[3]+-11.f*f[4]+8.f*f[5]+8.f*f[6]+8.f*f[7]+8.f*f[8]+-11.f*f[9]+8.f*f[10]+8.f*f[11]+8.f*f[12]+8.f*f[13]+-11.f*f[14]+8.f*f[15]+8.f*f[16]+8.f*f[17]+8.f*f[18];
        //float m6 = -4.f*f[2]+4.f*f[4]+f[5]+f[6]+-f[7]+-f[8]+f[11]+-f[13]+f[16]+-f[18];
        float m10 =-4.f*f[1]+2.f*f[2]+-4.f*f[3]+2.f*f[4]+f[5]+f[6]+f[7]+f[8]+2.f*f[9]+f[10]+-2.f*f[11]+f[12]+-2.f*f[13]+2.f*f[14]+f[15]+-2.f*f[16]+f[17]+-2.f*f[18];
        float m16 = f[5]+-f[6]+-f[7]+f[8]-f[10]+f[12]+-f[15]+f[17];
        float m[19] = {0};
        Moments_host(f,m);

        float omega = 1.0f/(3.0f*(UMAX*OBSTR1*2.f/RE)+0.5f);
        //float omega2 = 2.0f/(1.0f+2.0f*(2.0f/omega-1.0f));
        m[9] -= 2.f*u*u-(v*v+w*w);
        m[11]-= v*v-w*w;
        m[13]-= u*v;
        m[14]-= v*w;
        m[15]-= u*w;
        float PI11 = -0.5f *(m[ 9]);
        float PI22 = -(-38.f*m[ 9]-3.0f*m[11])/76.f;
        float PI33 = -(-38.f*m[ 9]+3.0f*m[11])/76.f;
        float PI12 = -1.5f*m[13];
        float PI23 = -1.5f*m[14];
        float PI13 = -1.5f*m[15];
        //we know Smag on coarse mesh
        float Smag = sqrt(2.f*(PI11*PI11+PI22*PI22+PI33*PI33+2.f*PI12*PI12+2.f*PI23*PI23+2.f*PI13*PI13));

        //InvertMoments_host(f,m);
        //u = m[3];
        //v = m[5];
        //w = m[7];
        //m6 = m[6 ];
        //m10= m[10];
        //m16= m[16];
        int z = (ZDIM/GPU_N*GPU+k);
        output<<i<<", "<<j<<", "<<z<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv[0][i+j*XDIM+k*XDIM*YDIM]<<","<<velAv[1][i+j*XDIM+k*XDIM*YDIM]<<", "
              //<<velFluc[0][i+j*XDIM+k*XDIM*YDIM]<<","<<Smag<<endl;
              <<velFluc[0][i+j*XDIM+k*XDIM*YDIM]<<","<<velFluc[1][i+j*XDIM+k*XDIM*YDIM]<<","<<Smag<<endl;
        if(k == 1 && GPU == 0){
        outputslice<<i<<", "<<j<<", "<<z<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv[0][i+j*XDIM+k*XDIM*YDIM]<<","<<velAv[1][i+j*XDIM+k*XDIM*YDIM]<<", "
              <<velFluc[0][i+j*XDIM+k*XDIM*YDIM]<<","<<velFluc[1][i+j*XDIM+k*XDIM*YDIM]<<","<<Smag<<endl;
        }
    }}}

    for(int j = 0; j<YDIM; j++){
    for(int i = 0; i<XDIM; i++){
        float rho = 0;
        for(int l = 0; l<19; l++){
            f[l] = hin[(i+j*XDIM)+l *XDIM*YDIM];
            rho += f[l];
        }
        float u = f[1]-f[3 ]+f[5 ]-f[6 ]-f[7 ]+f[8 ]+f[10]-f[12]+f[15]-f[17];
        float v = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
        float w = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
        output<<i<<", "<<j<<", "<<(ZDIM/GPU_N*(GPU+1)-1)<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv[0][i+j*XDIM+(ZDIM-1)*XDIM*YDIM]<<","<<velAv[1][i+j*XDIM+(ZDIM/GPU_N-1)*XDIM*YDIM]<<", "
              <<velFluc[0][i+j*XDIM+(ZDIM-1)*XDIM*YDIM]<<","<<velFluc[1][i+j*XDIM+(ZDIM/GPU_N-1)*XDIM*YDIM]<<","<<0<<endl;
    }}
}

void WriteResultsLR(ostream &output, ostream &outputslice, float *fin, float *gin, float *hin, float **velAv,  
                  float **velFluc, float omega, int GPU_N, int GPU)
{
    float f[19];
    output<<"VARIABLES = \"X\",\"Y\",\"Z\",\"u\",\"v\",\"w\",\"rho\",\"velAv[0]\",\"velAv[1]\",\"ufluc\",\"vfluc\",\"Smag\"\n";
    output<<"ZONE F=POINT, I="<<XLRDIM<<", J="<<YLRDIM<<", K="<<ZLRDIM/GPU_N<<"\n";
    if(GPU == 0){
    outputslice<<"VARIABLES = \"X\",\"Y\",\"Z\",\"u\",\"v\",\"w\",\"rho\",\"velAv[0]\",\"velAv[1]\",\"ufluc\",\"vfluc\",\"Smag\"\n";
    outputslice<<"ZONE F=POINT, I="<<XLRDIM<<", J="<<YLRDIM<<", K="<<1<<"\n";
    }

    for(int j = 0; j<YLRDIM; j++){
    for(int i = 0; i<XLRDIM; i++){
        float rho = 0;
        for(int l = 0; l<19; l++){
            f[l] = gin[(i+j*XLRDIM)+l *XLRDIM*YLRDIM];
            rho += f[l];
        }
        float u = f[1]-f[3 ]+f[5 ]-f[6 ]-f[7 ]+f[8 ]+f[10]-f[12]+f[15]-f[17];
        float v = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
        float w = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
        float x = LRX0+LRFACTOR*i;
        float y = LRY0+LRFACTOR*j;
        float z = LRZ0+LRFACTOR*(ZLRDIM/GPU_N*GPU);
        output<<x<<", "<<y<<", "<<z<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv[0][i+j*XLRDIM]<<","<<velAv[1][i+j*XLRDIM]<<", "<<velFluc[0][i+j*XLRDIM]<<","<<velFluc[1][i+j*XLRDIM]<<","<<0<<endl;
    }}

    for(int k = 1; k<ZLRDIM/GPU_N-1; k++){
    for(int j = 0; j<YLRDIM; j++){
    for(int i = 0; i<XLRDIM; i++){
        float rho = 0;
        for(int l = 0; l<19; l++){
            f[l] = fin[(i+j*XLRDIM)+(k-1)*XLRDIM*YLRDIM+l*XLRDIM*YLRDIM*(ZLRDIM/GPU_N-2)];
            rho += f[l];
        }
        float u = f[1]-f[3 ]+f[5 ]-f[6 ]-f[7 ]+f[8 ]+f[10]-f[12]+f[15]-f[17];
        float v = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
        float w = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
        float x = LRX0+LRFACTOR*i;
        float y = LRY0+LRFACTOR*j;
        float z = LRZ0+LRFACTOR*(ZLRDIM/GPU_N*GPU+k);

        float m[19] = {0};
        Moments_host(f,m);

        float omega = 1.0f/(3.0f*(UMAX*OBSTR1*2.f/RE)+0.5f);
        //float omega2 = 2.0f/(1.0f+2.0f*(2.0f/omega-1.0f));
        
        m[9] -= 2.f*u*u-(v*v+w*w);
        m[11]-= v*v-w*w;
        m[13]-= u*v;
        m[14]-= v*w;
        m[15]-= u*w;
        float PI11 = -0.5f *(m[ 9]);
        float PI22 = -(-38.f*m[ 9]-3.0f*m[11])/76.f;
        float PI33 = -(-38.f*m[ 9]+3.0f*m[11])/76.f;
        float PI12 = -1.5f*m[13];
        float PI23 = -1.5f*m[14];
        float PI13 = -1.5f*m[15];
        //we know Smag on coarse mesh
        float Smag = sqrt(2.f*(PI11*PI11+PI22*PI22+PI33*PI33+2.f*PI12*PI12+2.f*PI23*PI23+2.f*PI13*PI13))/LRFACTOR;

        output<<x<<", "<<y<<", "<<z<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv  [0][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<velAv  [1][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<", "
              //<<velFluc[0][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<Smag<<endl;
              <<velFluc[0][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<velFluc[1][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<Smag<<endl;
        if(k == 3 && GPU == 0){
        outputslice<<x<<", "<<y<<", "<<z<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv  [0][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<velAv  [1][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<", "
              <<velFluc[0][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<velFluc[1][i+j*XLRDIM+k*XLRDIM*YLRDIM]<<","<<Smag<<endl;
        }
    }}}

    for(int j = 0; j<YLRDIM; j++){
    for(int i = 0; i<XLRDIM; i++){
        float rho = 0;
        for(int l = 0; l<19; l++){
            f[l] = hin[(i+j*XLRDIM)+l *XLRDIM*YLRDIM];
            rho += f[l];
        }
        float u = f[1]-f[3 ]+f[5 ]-f[6 ]-f[7 ]+f[8 ]+f[10]-f[12]+f[15]-f[17];
        float v = f[2]-f[4 ]+f[5 ]+f[6 ]-f[7 ]-f[8 ]+f[11]-f[13]+f[16]-f[18];
        float w = f[9]+f[10]+f[11]+f[12]+f[13]-f[14]-f[15]-f[16]-f[17]-f[18];
        float x = LRX0+LRFACTOR*i;
        float y = LRY0+LRFACTOR*j;
        float z = LRZ0+LRFACTOR*(ZLRDIM/GPU_N*(GPU+1)-1);
        output<<x<<", "<<y<<", "<<z<<", "<<u<<","<<v<<","<<w<<","<<rho<<","
              <<velAv[0][i+j*XLRDIM+(ZLRDIM/GPU_N-1)*XLRDIM*YLRDIM]<<","<<velAv[1][i+j*XLRDIM+(ZLRDIM/GPU_N-1)*XLRDIM*YLRDIM]<<", "
              <<velFluc[0][i+j*XLRDIM+(ZLRDIM/GPU_N-1)*XLRDIM*YLRDIM]<<","<<velFluc[1][i+j*XLRDIM+(ZLRDIM/GPU_N-1)*XLRDIM*YLRDIM]<<","<<0<<endl;
    }}
}

void WriteForces(float **F, ofstream &output, int ForceTime, int level)
{
    float ref = UMAX*UMAX*ZDIM*OBSTR1;
    if(level > 0)
    ref *= LRLEVEL*LRLEVEL;
    for(int i = 0; i<ForceTime; i++){
        output<<i+STARTF<<", "<<F[0][i]/ref<<", "<<F[1][i]/ref<<", "<<F[2][i]/ref<<endl;
    }
}

void WriteAvV(float *v, ofstream &output)
{
    for(int i = 0; i<TMAX; i++){
        output<<i<<", "<<v[i]/(XDIM-2)/ZDIM<<endl;
    }
}

void WriteInputs(ostream &output, float omega, float omegaLR, int GPU_per_node)
{
    output<<"Base domain size \t"<<XDIM<<"x"<<YDIM<<"x"<<ZDIM<<endl;
    output<<"Base blocksize: \t"<<BLOCKSIZEX<<"x"<<BLOCKSIZEY<<"x"<<BLOCKSIZEZ<<endl;
    output<<"Obst1 location: \t("<<OBSTX1<<","<<OBSTY1<<","<<OBSTZ1<<")"<<endl;
    output<<"Obst1 radius: \t"<<OBSTR1<<endl;
    output<<"Obst2 location: \t("<<OBSTX2<<","<<OBSTY2<<","<<OBSTZ2<<")"<<endl;
    output<<"Obst2 radius: \t"<<OBSTR2<<endl;
    output<<"RE: \t"<<RE<<endl;
    output<<"UMAX: \t"<<UMAX<<endl;
    output<<"omega \t: "<<omega<<endl;
    output<<"TMAX: \t"<<TMAX<<endl;
    output<<"STARTF: \t"<<STARTF<<endl;
    output<<"START_VELAV: \t"<<START_VELAV<<endl;
    output<<"START_VELFLUC: \t"<<START_VELFLUC<<endl;
    output<<"REFINEMENT: \t"<<REFINEMENT<<endl;
    output<<"MODEL: \t"<<MODEL<<endl;
    output<<"Smagorinsky LES: \t"<<SmagLES<<endl;
    output<<"CS: \t"<<CS<<endl;
    output<<"LR domain size \t"<<XLRDIM<<"x"<<YLRDIM<<"x"<<ZLRDIM<<endl;
    output<<"LR factor \t"<<LRFACTOR<<endl;
    output<<"LR location \t"<<LRX0<<"x"<<LRY0<<"x"<<LRZ0<<endl;
    output<<"LR blocksize: \t"<<BLOCKSIZELRX<<"x"<<BLOCKSIZELRY<<"x"<<BLOCKSIZELRZ<<endl;   
    output<<"omega in LR \t: "<<omegaLR<<endl;
    output<<"GPUs per node \t: "<<GPU_per_node<<endl;
}


int main(int argc, char *argv[])
{
    
    int GPU_N; cudaGetDeviceCount(&GPU_N);
    GPU_N=NUMGPU;
    cout<<"number of GPUs: "<<GPU_N<<endl;

    ofstream output; ofstream outputForce; ofstream outputInputs; ofstream outputAvV;
    string FileName = CASENAME;
    output.open ((FileName+".dat").c_str());
    outputForce.open ((FileName+".force").c_str());
    outputInputs.open ((FileName+".inputs").c_str());
    outputAvV.open ((FileName+".vel").c_str());
    ofstream outputpart[REFINEMENT*GPU_N+GPU_N], outputslice;

    for(int i = 0; i< REFINEMENT*GPU_N+GPU_N; i++){
        //string filenum = to_string(i);
        char str[10];
        snprintf(str,10,"%i",i);
        outputpart[i].open ((FileName+"_part"+str+".dat").c_str());
    }
    outputslice.open ((FileName+"_slice.dat").c_str());



    //size_t memsize, memsize2;
    size_t pitch = 2;
    while(pitch<XDIM)
        pitch=pitch*2;
    pitch *= sizeof(float);//pitch*sizeof(float);
    size_t pitch_e = pitch/sizeof(float);
    cout<<"Pitch (in elements): "<<pitch/sizeof(float)<<endl;

    float CharLength = OBSTR1*2.f;

    float omega = 1.0f/(3.0f*(UMAX*CharLength/RE)+0.5f);
    float omegaLR = 2.0f/(1.0f+2.0f*(2.0f/omega-1.0f));
    if(LRFACTOR == 0.25f){
    omegaLR = 2.0f/(1.0f+2.0f*(2.0f/omegaLR-1.0f));
    }
    if(LRFACTOR == 0.125f){
    omegaLR = 2.0f/(1.0f+2.0f*(2.0f/omegaLR-1.0f));
    omegaLR = 2.0f/(1.0f+2.0f*(2.0f/omegaLR-1.0f));
    }
    float SF_cf = omega*(1.0f-omegaLR)/((1.0f-omega)*omegaLR/LRFACTOR);
    float SF_fc = 1.f/SF_cf;
    cout<<SF_cf<<endl;

    WriteInputs(outputInputs,omega,omegaLR,GPU_N);
    WriteInputs(cout,omega,omegaLR,GPU_N);

    if(abs(LRFACTOR-1.f/LRLEVEL)>0.001f && REFINEMENT == 1){
        cout<<"LRLEVEL and LRFACTOR don't match! Exiting..."<<endl;
        return 0;
    }

    int zInner = ZDIM/GPU_N-2; //excluding halo
    int ForceTime = max(0,TMAX-STARTF);

    dim3 threads(BLOCKSIZEX, BLOCKSIZEY, BLOCKSIZEZ);
    //2 halo layers per GPU (for 2 GPUs)
    dim3 grid  (((XDIM+BLOCKSIZEX-1)/BLOCKSIZEX),((YDIM+BLOCKSIZEY-1)/BLOCKSIZEY),(zInner)/BLOCKSIZEZ);
    dim3 g_grid(((XDIM+BLOCKSIZEX-1)/BLOCKSIZEX),((YDIM+BLOCKSIZEY-1)/BLOCKSIZEY),1);
    dim3 AvV_grid  (((XDIM+BLOCKSIZEX-1)/BLOCKSIZEX),1,(ZDIM)/BLOCKSIZEZ);

    cudaStream_t stream_halo[GPU_N];
    cudaStream_t stream_inner[GPU_N];

    //data pointers as 3D array (GPUxCoord)
    float   *f_h[GPU_N],   *g_h[GPU_N],   *h_h[GPU_N];
    float *f_d[GPU_N][2], *g_d[GPU_N][2], *h_d[GPU_N][2];
    float *g_temp[GPU_N], *h_temp[GPU_N];
    float *F_h[GPU_N][3];
    float *F_d[GPU_N][3];
    float *F_total[3];
    float *velAv_h[GPU_N][3],*velFluc_h[GPU_N][3];
    float *velAv_d[GPU_N][3],*velFluc_d[GPU_N][3];

    float *Av_V_h[GPU_N];
    float *Av_V_d[GPU_N];
    float dpdy = DPDY;

    for(int i = 0; i<3; i++)
    F_total[i] = (float *)malloc(ForceTime*sizeof(float));
    
    for(int i=0;i<3;i++)
    for(int j=0;j<(ForceTime);j++)
        F_total[i][j] = 0;

    //Malloc and Initialize for each GPU
    for(int n = 0; n<GPU_N; n++){
        f_h    [n] = (float *)malloc(XDIM*YDIM*zInner*19*sizeof(float));
        g_h    [n] = (float *)malloc(XDIM*YDIM*       19*sizeof(float));
        h_h    [n] = (float *)malloc(XDIM*YDIM*       19*sizeof(float));
        for(int i = 0; i<3; i++){
        F_h      [n][i] = (float *)malloc(ForceTime*sizeof(float));
        velAv_h  [n][i] = (float *)malloc(XDIM*YDIM*ZDIM/GPU_N*sizeof(float));
        velFluc_h[n][i] = (float *)malloc(XDIM*YDIM*ZDIM/GPU_N*sizeof(float));
        }
        Av_V_h[n] = (float *)malloc(TMAX*sizeof(float));
        cudaSetDevice(n);
        cudaStreamCreate(&stream_halo[n]);
        cudaStreamCreate(&stream_inner[n]);
        for(int m = 0; m<GPU_N; m++)
            if(m != n) cudaDeviceEnablePeerAccess(m,0);


        for(int i = 0; i<2; i++){
        cudaMalloc((void **) &f_d[n][i], pitch_e*YDIM*zInner*19*sizeof(float));
        cudaMalloc((void **) &g_d[n][i], pitch_e*YDIM*       19*sizeof(float));
        cudaMalloc((void **) &h_d[n][i], pitch_e*YDIM*       19*sizeof(float));
        }
        cudaMalloc((void **) & g_temp[n], pitch_e*YDIM*       19*sizeof(float));
        cudaMalloc((void **) & h_temp[n], pitch_e*YDIM*       19*sizeof(float));
        for(int i = 0; i<3; i++){
        cudaMalloc((void **) & F_d      [n][i], (ForceTime)*sizeof(float));
        cudaMalloc((void **) & velAv_d  [n][i], pitch_e*YDIM*ZDIM/GPU_N*sizeof(float));
        cudaMalloc((void **) & velFluc_d[n][i], pitch_e*YDIM*ZDIM/GPU_N*sizeof(float));
        }
        cudaMalloc((void **) & Av_V_d[n],TMAX*sizeof(float));


        //initialize host f_inner
        for (int i = 0; i < XDIM*YDIM*zInner*19; i++)
            f_h[n][i] = 0;
        //initialize host g,h
        for (int i = 0; i < XDIM*YDIM*19; i++){
            g_h[n][i] = 0;
            h_h[n][i] = 0;
        }
        for(int i=0;i<3;i++){
            for(int j=0;j<(ForceTime);j++)
                F_h[n][i][j] = 0;
            for (int j = 0; j < XDIM*YDIM*ZDIM/GPU_N; j++){
            velAv_h  [n][i][j] = 0;
            velFluc_h[n][i][j] = 0;
            }
        }
        for(int j=0;j<(ForceTime);j++)
            Av_V_h[n][j] = 0;
        for(int i = 0; i<2; i++){
        cudaMemcpy2D(f_d[n][i],pitch,f_h[n],XDIM*sizeof(float),XDIM*sizeof(float),YDIM*zInner*19,cudaMemcpyHostToDevice);
        cudaMemcpy2D(g_d[n][i],pitch,g_h[n],XDIM*sizeof(float),XDIM*sizeof(float),YDIM       *19,cudaMemcpyHostToDevice);
        cudaMemcpy2D(h_d[n][i],pitch,h_h[n],XDIM*sizeof(float),XDIM*sizeof(float),YDIM       *19,cudaMemcpyHostToDevice);
        }

        for(int i = 0; i<3; i++){
        cudaMemcpy2D(velAv_d  [n][i],pitch,velAv_h  [n][i],XDIM*sizeof(float),XDIM*sizeof(float),YDIM*ZDIM/GPU_N,cudaMemcpyHostToDevice);
        cudaMemcpy2D(velFluc_d[n][i],pitch,velFluc_h[n][i],XDIM*sizeof(float),XDIM*sizeof(float),YDIM*ZDIM/GPU_N,cudaMemcpyHostToDevice);
        cudaMemcpy(F_d[n][i],F_h[n][i],sizeof(float)*(ForceTime),cudaMemcpyHostToDevice);
        }
        cudaMemcpy(Av_V_d[n],Av_V_h[n],sizeof(float)*(TMAX),cudaMemcpyHostToDevice);

        //initialization kernels
        for(int i = 0; i<2; i++){
        initialize<<<  grid,threads>>>(f_d[n][i],pitch_e,zInner,GPU_N);
        initialize<<<g_grid,threads>>>(g_d[n][i],pitch_e,     1,GPU_N);
        initialize<<<g_grid,threads>>>(h_d[n][i],pitch_e,     1,GPU_N);
        }
        initialize<<<g_grid,threads>>>(g_temp[n],pitch_e,     1,GPU_N);
        initialize<<<g_grid,threads>>>(h_temp[n],pitch_e,     1,GPU_N);

    }//end Malloc and Initialize
    

    //data pointers as 3D array (GPUxCoord)
    float   *f_LR_h[GPU_N],   *g_LR_h[GPU_N],   *h_LR_h[GPU_N];
    float *f_LR_d[GPU_N][2], *g_LR_d[GPU_N][2], *h_LR_d[GPU_N][2];
    float *g_LR_temp[GPU_N], *h_LR_temp[GPU_N];
    float *velAv_LR_h[GPU_N][3],*velFluc_LR_h[GPU_N][3];
    float *velAv_LR_d[GPU_N][3],*velFluc_LR_d[GPU_N][3];
    float *f_interp[GPU_N], *g_interp[GPU_N], *h_interp[GPU_N], *g_interp_temp[GPU_N], *h_interp_temp[GPU_N];
    float *interp_h[GPU_N];

    size_t pitchLR = 2;
    while(pitchLR<XLRDIM)
        pitchLR=pitchLR*2;
    pitchLR = pitchLR*sizeof(float);
    size_t pitchLR_e = pitchLR/sizeof(float);
    cout<<"LR Pitch (in elements): "<<pitchLR_e<<endl;

    size_t pitchInterp = 2;
    while(pitchInterp<XLRDIM*LRFACTOR+1)
        pitchInterp=pitchInterp*2;
    pitchInterp = pitchInterp*sizeof(float);
    size_t pitchInterp_e = pitchInterp/sizeof(float);
    cout<<"Interp Pitch (in elements): "<<pitchInterp_e<<endl;

    int zLRInner = ZLRDIM/GPU_N-2;
    dim3 LR_threads(BLOCKSIZELRX, BLOCKSIZELRY, BLOCKSIZELRZ);
    dim3 LR_grid(((XLRDIM+BLOCKSIZELRX-1)/BLOCKSIZELRX),((YLRDIM+BLOCKSIZELRY-1)/BLOCKSIZELRY),(zLRInner)/BLOCKSIZELRZ);
    dim3 g_LR_grid(((XLRDIM+BLOCKSIZELRX-1)/BLOCKSIZELRX),((YLRDIM+BLOCKSIZELRY-1)/BLOCKSIZELRY),1);    
    
    dim3 Interp_threads(BLOCKSIZEINTERP, LRLEVEL, LRLEVEL);
    dim3 Interp_grid(((XLRDIM+BLOCKSIZEINTERP-1)/BLOCKSIZEINTERP),((YLRDIM+LRLEVEL-1)/LRLEVEL),ZLRDIM/LRLEVEL/GPU_N);
    cout<<((XLRDIM+BLOCKSIZEINTERP-1)/BLOCKSIZEINTERP)<<", "<<((YLRDIM+LRLEVEL-1)/LRLEVEL)<<", "<<ZLRDIM/LRLEVEL/GPU_N<<endl;

    dim3 Interp_grid_c(((XDIM+BLOCKSIZEX-1)/BLOCKSIZEX),((YDIM+BLOCKSIZEY-1)/BLOCKSIZEY),(ZDIM/GPU_N)/BLOCKSIZEZ);
    

    //setup LR
    if(REFINEMENT == 1){

    for(int n = 0; n<GPU_N; n++){
        f_LR_h    [n] = (float *)malloc(XLRDIM*YLRDIM*zLRInner*19*sizeof(float));
        g_LR_h    [n] = (float *)malloc(XLRDIM*YLRDIM*         19*sizeof(float));
        h_LR_h    [n] = (float *)malloc(XLRDIM*YLRDIM*         19*sizeof(float));
        interp_h  [n] = (float *)malloc((XLRDIM*LRFACTOR+1)*(YLRDIM*LRFACTOR+1)*zInner*9*sizeof(float));
        for(int i = 0; i<3; i++){
        velAv_LR_h  [n][i] = (float *)malloc(XLRDIM*YLRDIM*ZLRDIM/GPU_N*sizeof(float));
        velFluc_LR_h[n][i] = (float *)malloc(XLRDIM*YLRDIM*ZLRDIM/GPU_N*sizeof(float));
        }
        cudaSetDevice(n);
        for(int i = 0; i<2; i++){
        cudaMalloc((void **) &f_LR_d[n][i], pitchLR_e*YLRDIM*zLRInner*19*sizeof(float));
        cudaMalloc((void **) &g_LR_d[n][i], pitchLR_e*YLRDIM*         19*sizeof(float));
        cudaMalloc((void **) &h_LR_d[n][i], pitchLR_e*YLRDIM*         19*sizeof(float));
        }
        cudaMalloc((void **) & g_LR_temp[n], pitchLR_e*YLRDIM*       19*sizeof(float));
        cudaMalloc((void **) & h_LR_temp[n], pitchLR_e*YLRDIM*       19*sizeof(float));
        cudaMalloc((void **) & f_interp[n], pitchInterp_e*(YLRDIM*LRFACTOR+1)*zInner*9*sizeof(float));
        cudaMalloc((void **) & g_interp[n], pitchInterp_e*(YLRDIM*LRFACTOR+1)*9*sizeof(float));
        cudaMalloc((void **) & h_interp[n], pitchInterp_e*(YLRDIM*LRFACTOR+1)*9*sizeof(float));
        cudaMalloc((void **) & g_interp_temp[n], pitchInterp_e*(YLRDIM*LRFACTOR+1)*9*sizeof(float));
        cudaMalloc((void **) & h_interp_temp[n], pitchInterp_e*(YLRDIM*LRFACTOR+1)*9*sizeof(float));
        for(int i = 0; i<3; i++){
        cudaMalloc((void **) & velAv_LR_d  [n][i], pitchLR_e*YLRDIM*ZLRDIM/GPU_N*sizeof(float));
        cudaMalloc((void **) & velFluc_LR_d[n][i], pitchLR_e*YLRDIM*ZLRDIM/GPU_N*sizeof(float));
        }
        for (int i = 0; i < XLRDIM*YLRDIM*zLRInner*19; i++)
            f_LR_h[n][i] = 0;
        //initialize host g,h
        for (int i = 0; i < XLRDIM*YLRDIM*19; i++){
            g_LR_h[n][i] = 0;
            h_LR_h[n][i] = 0;
        }
        for(int i=0;i<3;i++){
            for (int j = 0; j < XLRDIM*YLRDIM*ZLRDIM/GPU_N; j++){
            velAv_LR_h  [n][i][j] = 0;
            velFluc_LR_h[n][i][j] = 0;
            }
        }
        for(int i = 0; i<2; i++){
        cudaMemcpy2D(f_LR_d[n][i],pitchLR,f_LR_h[n],XLRDIM*sizeof(float),XLRDIM*sizeof(float),YLRDIM*zLRInner*19,cudaMemcpyHostToDevice);
        cudaMemcpy2D(g_LR_d[n][i],pitchLR,g_LR_h[n],XLRDIM*sizeof(float),XLRDIM*sizeof(float),YLRDIM         *19,cudaMemcpyHostToDevice);
        cudaMemcpy2D(h_LR_d[n][i],pitchLR,h_LR_h[n],XLRDIM*sizeof(float),XLRDIM*sizeof(float),YLRDIM         *19,cudaMemcpyHostToDevice);
        }
        for(int i = 0; i<3; i++){
        cudaMemcpy2D(velAv_LR_d  [n][i],pitchLR,velAv_LR_h  [n][i],XLRDIM*sizeof(float),XLRDIM*sizeof(float),YLRDIM*ZLRDIM/GPU_N,cudaMemcpyHostToDevice);
        cudaMemcpy2D(velFluc_LR_d[n][i],pitchLR,velFluc_LR_h[n][i],XLRDIM*sizeof(float),XLRDIM*sizeof(float),YLRDIM*ZLRDIM/GPU_N,cudaMemcpyHostToDevice);
        }
        //initialization kernels
        for(int i = 0; i<2; i++){
        initializeLR<<<  LR_grid,LR_threads>>>(f_LR_d[n][i],pitchLR_e,zLRInner,GPU_N);
        initializeLR<<<g_LR_grid,LR_threads>>>(g_LR_d[n][i],pitchLR_e,       1,GPU_N);
        initializeLR<<<g_LR_grid,LR_threads>>>(h_LR_d[n][i],pitchLR_e,       1,GPU_N);
        }
        initializeLR<<<g_LR_grid,LR_threads>>>(g_LR_temp[n],pitchLR_e,       1,GPU_N);
        initializeLR<<<g_LR_grid,LR_threads>>>(h_LR_temp[n],pitchLR_e,       1,GPU_N);



    }//end of GPU loop for malloc and initialize for LR
    }//end of LR malloc and initialize


	cudaFuncSetCacheConfig(InterpCF,cudaFuncCachePreferShared);


    int A = 0; int B = 1; int C = 0; int D = 1;

    for(int n = 0; n<GPU_N; n++){
    cudaSetDevice(n);
    size_t mem_avail, mem_total;
    cudaMemGetInfo(&mem_avail,&mem_total);
    cout<<"Device memory used for dev"<<n<<" : "<<(mem_total-mem_avail)*pow(10,-9)<<" GB\n";
    cout<<"Device memory available for dev"<<n<<" : "<<(mem_avail)*pow(10,-9)<<" GB\n";
    }
    
    struct timeval tdr0,tdr1;
    double restime;
    cudaDeviceSynchronize();
    gettimeofday (&tdr0,NULL);
    
    //time loop
    for(int t = 0; t<TMAX; t++)
    {
        //copy temporary array for top and bottom on coarse mesh to neighbor GPU. Only transfering 5 distbs
        for(int n = 0; n<GPU_N; n++)
            cudaMemcpyPeerAsync(&h_temp[n][pitch_e*YDIM*14],n,&g_d[   (n+1)%GPU_N][A][pitch_e*YDIM*14],   (n+1)%GPU_N,pitch_e*YDIM*sizeof(float)*5,stream_halo[n]);
        for(int n = 0; n<GPU_N; n++)
            cudaMemcpyPeerAsync(&g_temp[n][pitch_e*YDIM*9],n,&h_d[abs(n-1)%GPU_N][A][pitch_e*YDIM*9],abs(n-1)%GPU_N,pitch_e*YDIM*sizeof(float)*5,stream_halo[n]);

        //compute inner nodes on coarse mesh
        for(int n = 0; n<GPU_N; n++){
            cudaSetDevice(n);
            update_inn<<<grid,threads,0,stream_inner[n]>>>(f_d[n][B],f_d[n][A],g_d[n][A], h_d[n][A],omega,pitch_e,n,zInner,velAv_d[n][0],velAv_d[n][1],velFluc_d[n][0],velFluc_d[n][1],F_d[n][0],F_d[n][1],F_d[n][2],t,(!REFINEMENT&&t>STARTF),f_interp[n],pitchInterp_e,dpdy);
        }

        //synchronize halo stream before computing top and bottom nodes
        for(int n = 0; n<GPU_N; n++)
        cudaStreamSynchronize(stream_halo[n]);

        //compute top and bottom nodes
        for(int n = 0; n<GPU_N; n++)
        {
            cudaSetDevice(n);
            update_top<<<g_grid, threads, 0, stream_halo [n]>>>(h_d[n][B],h_d[n][A],f_d[n][A],h_temp[n],omega,pitch_e,n,zInner,F_d[n][0],F_d[n][1],F_d[n][2],t,(!REFINEMENT&&t>STARTF),h_interp[n],pitchInterp_e,dpdy);
            update_bot<<<g_grid, threads, 0, stream_halo [n]>>>(g_d[n][B],g_d[n][A],f_d[n][A],g_temp[n],omega,pitch_e,n,zInner,F_d[n][0],F_d[n][1],F_d[n][2],t,(!REFINEMENT&&t>STARTF),g_interp[n],pitchInterp_e,dpdy);
        }

        for(int n = 0; n<GPU_N; n++)
        {
            AverageV<<<AvV_grid, threads, 0, stream_halo [n]>>>(f_d[n][B],g_d[n][B],h_d[n][B],pitch_e,n,zInner,Av_V_d[n],t);
        }

        if(t%100 == 0 && t>5000)
        {
        for(int n = 0; n<GPU_N; n++)
        cudaMemcpy(&Av_V_h[n][t],&Av_V_d[n][t],sizeof(float),cudaMemcpyDeviceToHost);

        float Av_V = 0;
        for(int n = 0; n<GPU_N; n++)
        Av_V += Av_V_h[n][t];
        Av_V /= (XDIM-2)*ZDIM;
        float diff;
        diff = (Av_V-UMAX)/UMAX;
        dpdy += diff*KP*abs(DPDY);
        //dpdy = max(DPDY*)
//        if(Av_V < UMAX*0.995f)
//            dpdy *= 1.01f;
//        else if(Av_V > UMAX*1.005f)
//            dpdy *= 0.99f;
        if(t%1000 == 0) outputAvV<<t<<", "<<Av_V<<", "<<dpdy<<endl;
        }

        

        //cudaDeviceSynchronize();
        swap(A,B);



        if(REFINEMENT == 1){
        int flag_F = 0;
        for(int i = 0; i<LRLEVEL; i++){
            if(t>STARTF && i == 0) flag_F = 1;
            else flag_F = 0;
            for(int n = 0; n<GPU_N; n++){
            cudaMemcpyPeerAsync(&h_LR_temp[n][pitchLR_e*YLRDIM*14],n,&g_LR_d[   (n+1)%GPU_N][C][pitchLR_e*YLRDIM*14],   (n+1)%GPU_N,pitchLR_e*YLRDIM*sizeof(float)*5,stream_halo[n]);
            cudaMemcpyPeerAsync(&g_LR_temp[n][pitchLR_e*YLRDIM*9 ],n,&h_LR_d[abs(n-1)%GPU_N][C][pitchLR_e*YLRDIM*9 ],abs(n-1)%GPU_N,pitchLR_e*YLRDIM*sizeof(float)*5,stream_halo[n]);
            }

       
            for(int n = 0; n<GPU_N; n++){
    		cudaSetDevice(n);
            update_inn_LR<<<LR_grid,LR_threads,0,stream_inner[n]>>>(f_LR_d[n][D],f_LR_d[n][C],g_LR_d[n][C], h_LR_d[n][C],omegaLR,pitchLR_e,n,zLRInner,velAv_LR_d[n][0],velAv_LR_d[n][1],velFluc_LR_d[n][0],velFluc_LR_d[n][1],F_d[n][0],F_d[n][1],F_d[n][2],t,flag_F);
            }
            for(int n = 0; n<GPU_N; n++)
    		cudaStreamSynchronize(stream_halo[n]);
 
            for(int n = 0; n<GPU_N; n++){
            cudaSetDevice(n);
            update_top_LR<<<g_LR_grid,LR_threads,0,stream_halo[n]>>>(h_LR_d[n][D],h_LR_d[n][C],f_LR_d[n][C],h_LR_temp[n],omegaLR,pitchLR_e,n,zLRInner,F_d[n][0],F_d[n][1],F_d[n][2],t,flag_F);
            update_bot_LR<<<g_LR_grid,LR_threads,0,stream_halo[n]>>>(g_LR_d[n][D],g_LR_d[n][C],f_LR_d[n][C],g_LR_temp[n],omegaLR,pitchLR_e,n,zLRInner,F_d[n][0],F_d[n][1],F_d[n][2],t,flag_F);
            }
   

        if(i == LRLEVEL-1)
        {
        for(int n = 0; n<GPU_N; n++)
            //cudaMemcpyPeerAsync(&h_interp_temp[n][0],n,&g_interp[   (n+1)%GPU_N][0],   (n+1)%GPU_N,pitchInterp_e*(YLRDIM*LRFACTOR+1)*sizeof(float)*9,stream_halo[n]);
        for(int n = 0; n<GPU_N; n++)
            cudaMemcpyPeerAsync(&g_interp_temp[n][0],n,&h_interp[abs(n-1)%GPU_N][0],abs(n-1)%GPU_N,pitchInterp_e*(YLRDIM*LRFACTOR+1)*sizeof(float)*9,stream_halo[n]);
        }


            for(int n = 0; n<GPU_N; n++){
    		cudaSetDevice(n);
    		cudaDeviceSynchronize();
            }
            flag_F = 0;
            swap(C,D);
        }

        //interp from coarse grid 
        for(int n = 0; n<GPU_N; n++){
        cudaSetDevice(n);
        InterpCF<<<Interp_grid,Interp_threads,0,stream_inner[n]>>>(f_LR_d[n][C],g_LR_d[n][C],h_LR_d[n][C],pitchLR_e,f_interp[n],g_interp[n],h_interp[n],g_interp_temp[n],pitchInterp_e,SF_cf,omega,n,zInner,zLRInner);
        //cudaDeviceSynchronize();
        }

        //interp from fine grid
        for(int n = 0; n<GPU_N; n++){
        cudaSetDevice(n);
        cudaMemcpyPeerAsync(&h_LR_temp[n][0],n,&g_LR_d[   (n+1)%GPU_N][C][0],   (n+1)%GPU_N,pitchLR_e*YLRDIM*sizeof(float)*19,stream_halo[n]);
        }
        for(int n = 0; n<GPU_N; n++)
        cudaStreamSynchronize(stream_halo[n]);
        for(int n = 0; n<GPU_N; n++){
        cudaSetDevice(n);
        InterpFC<<<Interp_grid_c,threads,0,stream_halo[n]>>>(f_d[n][A],g_d[n][A],h_d[n][A],f_LR_d[n][C],h_LR_d[n][C],h_LR_temp[n],pitch_e,pitchLR_e,SF_fc,omegaLR,n,zInner,zLRInner);
        }

        }//end refinement

        for(int n = 0; n<GPU_N; n++){
        cudaSetDevice(n);
        cudaDeviceSynchronize();
        }


    }//end time loop


    cudaDeviceSynchronize();
    gettimeofday (&tdr1,NULL);
    timeval_subtract (&restime, &tdr1, &tdr0);
    int Nodes;
    Nodes = XDIM*YDIM*ZDIM;
    if (REFINEMENT == 1)
        Nodes += XLRDIM*YLRDIM*ZLRDIM*LRLEVEL;
    cout<<"Time taken for main kernel: "<<restime<<" ("
            <<double(Nodes*double(TMAX/1000000.f))/restime<<"MLUPS)\n";

    //D2H Memcpy and write results
    for(int n = 0; n<GPU_N; n++){
        cudaSetDevice(n);
        cudaMemcpy2D(f_h[n],XDIM*sizeof(float),f_d[n][A],pitch,XDIM*sizeof(float),YDIM*zInner*19,cudaMemcpyDeviceToHost);
        cudaMemcpy2D(g_h[n],XDIM*sizeof(float),g_d[n][A],pitch,XDIM*sizeof(float),YDIM       *19,cudaMemcpyDeviceToHost);
        cudaMemcpy2D(h_h[n],XDIM*sizeof(float),h_d[n][A],pitch,XDIM*sizeof(float),YDIM       *19,cudaMemcpyDeviceToHost);
        for(int i = 0; i<3; i++){
        cudaMemcpy2D(  velAv_h[n][i],XDIM*sizeof(float),velAv_d[n][i],pitch,XDIM*sizeof(float),YDIM*ZDIM/GPU_N,cudaMemcpyDeviceToHost);
        cudaMemcpy2D(velFluc_h[n][i],XDIM*sizeof(float),velFluc_d[n][i],pitch,XDIM*sizeof(float),YDIM*ZDIM/GPU_N,cudaMemcpyDeviceToHost);
        cudaMemcpy(F_h[n][i],F_d[n][i],sizeof(float)*ForceTime,cudaMemcpyDeviceToHost);
        }
        cudaMemcpy(Av_V_h[n],Av_V_d[n],sizeof(float)*TMAX,cudaMemcpyDeviceToHost);
        WriteResults(outputpart[n],outputslice,f_h[n],g_h[n],h_h[n],velAv_h[n],velFluc_h[n],omega,GPU_N,n);
        outputpart[n]<<endl;

        for(int i=0;i<3;i++)
        for(int j=0;j<ForceTime;j++)
            F_total[i][j] += F_h[n][i][j];

        if(n > 0){
        for(int j=0;j<TMAX;j++)
            Av_V_h[0][j] += Av_V_h[n][j];
        }
        
        for(int i = 0; i<2; i++){
            cudaFree(f_d[n][i]);
            cudaFree(g_d[n][i]);
            cudaFree(h_d[n][i]);
        }
        cudaFree(f_d[n]);
        cudaFree(g_d[n]);
        cudaFree(h_d[n]);
        cudaFree(g_temp[n]);
        cudaFree(h_temp[n]);
        for(int i=0;i<3;i++)
            cudaFree(F_d[n][i]);
        cudaFree(F_d[n]);
    }//end Memcpy and write results
    WriteForces(F_total,outputForce,ForceTime,REFINEMENT*LRLEVEL);
    //WriteAvV(Av_V_h[0],outputAvV);


    if(REFINEMENT == 1){
//    output<<"VARIABLES = \"X\",\"Y\",\"Z\",\"u\",\"v\",\"w\",\"rho\",\"uAv\",\"vAv\",\"ufluc\",\"vfluc\"\n";
//    output<<"ZONE F=POINT, I="<<XLRDIM<<", J="<<YLRDIM<<", K="<<ZLRDIM<<"\n";
    for(int n = 0; n<GPU_N; n++){
        cudaSetDevice(n);
        cudaMemcpy2D(f_LR_h[n],XLRDIM*sizeof(float),f_LR_d[n][C],pitchLR,XLRDIM*sizeof(float),YLRDIM*zLRInner*19,cudaMemcpyDeviceToHost);
        cudaMemcpy2D(g_LR_h[n],XLRDIM*sizeof(float),g_LR_d[n][C],pitchLR,XLRDIM*sizeof(float),YLRDIM         *19,cudaMemcpyDeviceToHost);
        cudaMemcpy2D(h_LR_h[n],XLRDIM*sizeof(float),h_LR_d[n][C],pitchLR,XLRDIM*sizeof(float),YLRDIM         *19,cudaMemcpyDeviceToHost);
        //cudaMemcpy2D(interp_h[n],(XLRDIM*LRFACTOR+1)*sizeof(float),f_interp[n],pitchInterp,(XLRDIM*LRFACTOR+1)*sizeof(float),(YLRDIM*LRFACTOR+1)*zInner*9,cudaMemcpyDeviceToHost);
        for(int i = 0; i<3; i++){
        cudaMemcpy2D(  velAv_LR_h[n][i],XLRDIM*sizeof(float),velAv_LR_d[n][i],pitchLR,XLRDIM*sizeof(float),YLRDIM*ZLRDIM/GPU_N,cudaMemcpyDeviceToHost);
        cudaMemcpy2D(velFluc_LR_h[n][i],XLRDIM*sizeof(float),velFluc_LR_d[n][i],pitchLR,XLRDIM*sizeof(float),YLRDIM*ZLRDIM/GPU_N,cudaMemcpyDeviceToHost);
        }
        WriteResultsLR(outputpart[GPU_N+n],outputslice,f_LR_h[n],g_LR_h[n],h_LR_h[n],velAv_LR_h[n],velFluc_LR_h[n],omegaLR,GPU_N,n);
        outputpart[GPU_N+n]<<endl;

        for(int i = 0; i<2; i++){
            cudaFree(f_LR_d[n][i]);
            cudaFree(g_LR_d[n][i]);
            cudaFree(h_LR_d[n][i]);
        }
        cudaFree(f_LR_d[n]);
        cudaFree(g_LR_d[n]);
        cudaFree(h_LR_d[n]);
        cudaFree(g_LR_temp[n]);
        cudaFree(h_LR_temp[n]);
    }
    }


    return 0;
}
